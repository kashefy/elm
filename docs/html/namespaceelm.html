<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<title>ELM Library: elm Namespace Reference</title>

<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>


</head>
<body>
<div id="top"><!-- do not remove this div! -->


<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  
  
  <td style="padding-left: 0.5em;">
   <div id="projectname">ELM Library
   &#160;<span id="projectnumber">devel</span>
   </div>
   
  </td>
  
  
  
 </tr>
 </tbody>
</table>
</div>

<!-- Generated by Doxygen 1.7.6.1 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li class="current"><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="namespaces.html"><span>Namespace&#160;List</span></a></li>
      <li><a href="namespacemembers.html"><span>Namespace&#160;Members</span></a></li>
    </ul>
  </div>
</div>
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
  initNavTree('namespaceelm.html','');
</script>
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#namespaces">Namespaces</a> &#124;
<a href="#nested-classes">Classes</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">elm Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="namespaces"></a>
Namespaces</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceelm_1_1detail.html">detail</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceelm_1_1pod.html">pod</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceelm_1_1ts.html">ts</a></td></tr>
<tr><td colspan="2"><h2><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classelm_1_1SignalPy.html">SignalPy</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Python wrapper around <a class="el" href="classelm_1_1Signal.html" title="The Signal class, a class for holding single and multiple samples of features.">Signal</a> class.  <a href="classelm_1_1SignalPy.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classelm_1_1base__Layer.html">base_Layer</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">The Layer base class Overloaded constructor calls overloaded <a class="el" href="classelm_1_1base__Layer.html#a421520cd909add1589ff040764e952db" title="Reset the state of the layer with new configurations.">Reset()</a> so you can implement Reset(config) directly.  <a href="classelm_1_1base__Layer.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structelm_1_1translator__CvTermCriteria.html">translator_CvTermCriteria</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">STL string &lt;-&gt; OpenCV CvTermCriteria translator for adding CvTermCriteria to boost property trees.  <a href="structelm_1_1translator__CvTermCriteria.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structelm_1_1translator__MapSS.html">translator_MapSS</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">STL string &lt;-&gt; Map&lt;string,string&gt; translator for adding MapSS objects to boost property trees.  <a href="structelm_1_1translator__MapSS.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structelm_1_1translator__VecI.html">translator_VecI</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">STL string &lt;-&gt; OpenCV CvTermCriteria translator for adding CvTermCriteria to boost property trees.  <a href="structelm_1_1translator__VecI.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classelm_1_1DeferredAssign__.html">DeferredAssign_</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">class for deferring Mat element assignment operations  <a href="classelm_1_1DeferredAssign__.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classelm_1_1DeferredAssignHashed__.html">DeferredAssignHashed_</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">class for deferring Mat element assignment operations  <a href="classelm_1_1DeferredAssignHashed__.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classelm_1_1LUT.html">LUT</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classelm_1_1LUT.html" title="LUT class since OpenCV&#39;s only supports LUT with 8-bit depth.">LUT</a> class since OpenCV's only supports <a class="el" href="classelm_1_1LUT.html" title="LUT class since OpenCV&#39;s only supports LUT with 8-bit depth.">LUT</a> with 8-bit depth.  <a href="classelm_1_1LUT.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classelm_1_1Exception.html">Exception</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">The <a class="el" href="classelm_1_1Exception.html" title="The Exception class adapted from OpenCV&#39;s Exception class.">Exception</a> class adapted from OpenCV's <a class="el" href="classelm_1_1Exception.html" title="The Exception class adapted from OpenCV&#39;s Exception class.">Exception</a> class.  <a href="classelm_1_1Exception.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classelm_1_1ExceptionBadDims.html">ExceptionBadDims</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classelm_1_1ExceptionNotImpl.html">ExceptionNotImpl</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classelm_1_1ExceptionFileIOError.html">ExceptionFileIOError</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classelm_1_1ExceptionValueError.html">ExceptionValueError</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classelm_1_1ExceptionKeyError.html">ExceptionKeyError</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classelm_1_1ExceptionTypeError.html">ExceptionTypeError</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classelm_1_1FeatureData.html">FeatureData</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">The Feature data class.  <a href="classelm_1_1FeatureData.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classelm_1_1base__GraphVertexOp.html">base_GraphVertexOp</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Interface for defining operators to use with <a class="el" href="classelm_1_1GraphAttr.html#acb25f252fe2a046eaa10d0711010c6d7" title="apply function to source image map masked by vertex">elm::GraphAttr::applyVertexToMap()</a> and <a class="el" href="classelm_1_1GraphAttr.html#a291782068bfe3ec7597ed4a9acb872f6" title="apply function to source image map masked by vertex for each vertex">elm::GraphAttr::applyVerticesToMap()</a>  <a href="classelm_1_1base__GraphVertexOp.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classelm_1_1Graph.html">Graph</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">class for exposing public interface of <a class="el" href="structelm_1_1Graph__Impl.html" title="full Graph implementation class">Graph_Impl</a> External face of <a class="el" href="classelm_1_1Graph.html" title="class for exposing public interface of Graph_Impl External face of Graph pimpl.">Graph</a> pimpl.  <a href="classelm_1_1Graph.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structelm_1_1Graph__Impl.html">Graph_Impl</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">full <a class="el" href="classelm_1_1Graph.html" title="class for exposing public interface of Graph_Impl External face of Graph pimpl.">Graph</a> implementation class  <a href="structelm_1_1Graph__Impl.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classelm_1_1GraphAttr.html">GraphAttr</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">class for exposing the public interface of <a class="el" href="classelm_1_1GraphAttr__Impl.html" title="full GraphAttr implementation class Enforces a list of unique vertices accroding to their main proper...">GraphAttr_Impl</a> An attributed graph class where the attributes are encapsulated inside a single-channel OpenCV Mat of floats External face of <a class="el" href="classelm_1_1GraphAttr.html" title="class for exposing the public interface of GraphAttr_Impl An attributed graph class where the attribu...">GraphAttr</a> pimpl.  <a href="classelm_1_1GraphAttr.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classelm_1_1GraphAttr__Impl.html">GraphAttr_Impl</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">full <a class="el" href="classelm_1_1GraphAttr.html" title="class for exposing the public interface of GraphAttr_Impl An attributed graph class where the attribu...">GraphAttr</a> implementation class Enforces a list of unique vertices accroding to their main property  <a href="classelm_1_1GraphAttr__Impl.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classelm_1_1VertexCache.html">VertexCache</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">class for Vertex Id and descriptor caching and recording of subtitutions  <a href="classelm_1_1VertexCache.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classelm_1_1InputName.html">InputName</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">class for repsresenting layer input names  <a href="classelm_1_1InputName.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classelm_1_1LayerConfig.html">LayerConfig</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classelm_1_1LayerInputNames.html">LayerInputNames</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">class for encapsulating layer input/stimulus key-name pairs  <a href="classelm_1_1LayerInputNames.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classelm_1_1LayerIONames.html">LayerIONames</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">class for merging input/stimuli and output/response layer names  <a href="classelm_1_1LayerIONames.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classelm_1_1LayerOutputNames.html">LayerOutputNames</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">class for encapsulating layer IO key-name pairs  <a href="classelm_1_1LayerOutputNames.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classelm_1_1Cloud__2Cloud__.html">Cloud_2Cloud_</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">class for Point Cloud conversion of different point types  <a href="classelm_1_1Cloud__2Cloud__.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classelm_1_1ConverterCloudMat__.html">ConverterCloudMat_</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Template class with utilities for Cloud-Mat conversions depending on Point type.  <a href="classelm_1_1ConverterCloudMat__.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classelm_1_1PCLPointTraits__.html">PCLPointTraits_</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">template class to for wrapping PCL point traits  <a href="classelm_1_1PCLPointTraits__.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classelm_1_1Percentile.html">Percentile</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">class for calculating percentile in a matrix  <a href="classelm_1_1Percentile.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classelm_1_1Registor__.html">Registor_</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">class for registering derived instantances Partially inspired by: <a href="http://stackoverflow.com/questions/582331/is-there-a-way-to-instantiate-objects-from-a-string-holding-their-class-name">http://stackoverflow.com/questions/582331/is-there-a-way-to-instantiate-objects-from-a-string-holding-their-class-name</a>  <a href="classelm_1_1Registor__.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classelm_1_1base__Sampler.html">base_Sampler</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">base class for sampling from a distribution  <a href="classelm_1_1base__Sampler.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classelm_1_1Sampler1D.html">Sampler1D</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">class for sampling from 1D PDF  <a href="classelm_1_1Sampler1D.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classelm_1_1PoissonProcess.html">PoissonProcess</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Class for simulating f-Hz Poisson process.  <a href="classelm_1_1PoissonProcess.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classelm_1_1Sampler2D.html">Sampler2D</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">class for sampling from two-dimensional PDF  <a href="classelm_1_1Sampler2D.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classelm_1_1Signal.html">Signal</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">The <a class="el" href="classelm_1_1Signal.html" title="The Signal class, a class for holding single and multiple samples of features.">Signal</a> class, a class for holding single and multiple samples of features.  <a href="classelm_1_1Signal.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classelm_1_1Signal__.html">Signal_</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">The template <a class="el" href="classelm_1_1Signal.html" title="The Signal class, a class for holding single and multiple samples of features.">Signal</a> class, a class for holding single and multiple samples of features.  <a href="classelm_1_1Signal__.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classelm_1_1Signal__Impl.html">Signal_Impl</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">The <a class="el" href="classelm_1_1Signal.html" title="The Signal class, a class for holding single and multiple samples of features.">Signal</a> Implementation class, a class for holding single and multiple samples of features.  <a href="classelm_1_1Signal__Impl.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classelm_1_1VisitorCloud__.html">VisitorCloud_</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">A template visitor class for converting to pcl point clouds, and keeping track of when a heavy conversion (involving deep copy) occured.  <a href="classelm_1_1VisitorCloud__.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classelm_1_1VisitorMat1f.html">VisitorMat1f</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">visitor class for converting to Mat of floats  <a href="classelm_1_1VisitorMat1f.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classelm_1_1VisitorPOD__.html">VisitorPOD_</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">template class for scalar POD static visitors  <a href="classelm_1_1VisitorPOD__.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classelm_1_1VisitorSparseMat1f.html">VisitorSparseMat1f</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">visitor class for converting to a sparse Mat of floats  <a href="classelm_1_1VisitorSparseMat1f.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classelm_1_1VisitorVecMat1f.html">VisitorVecMat1f</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">visitor class for converting to vector of Mats of floats  <a href="classelm_1_1VisitorVecMat1f.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classelm_1_1VisitorVecVertices.html">VisitorVecVertices</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">visitor class for converting to STL vector of PCL vertices And keeping track of when a heavy conversion (involving deep copy) occured  <a href="classelm_1_1VisitorVecVertices.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classelm_1_1base__FilterBank.html">base_FilterBank</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">base class for filter banks The interface should aid in iterating through response by defining different iterators, whether kernel-by-kernel or element response acorss all kernels  <a href="classelm_1_1base__FilterBank.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classelm_1_1base__PopulationCode.html">base_PopulationCode</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">The base class for population codes.  <a href="classelm_1_1base__PopulationCode.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classelm_1_1Gabors.html">Gabors</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classelm_1_1base__StatefulPopulationCode.html">base_StatefulPopulationCode</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">a base class for population codes that are stateful  <a href="classelm_1_1base__StatefulPopulationCode.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classelm_1_1MutexPopulationCode.html">MutexPopulationCode</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Mutually exclusive population code (a.k.a simple pop.  <a href="classelm_1_1MutexPopulationCode.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classelm_1_1SoftMaxPopulationCode.html">SoftMaxPopulationCode</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Population code sampled from distribution (e.g.  <a href="classelm_1_1SoftMaxPopulationCode.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classelm_1_1base__Reader.html">base_Reader</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classelm_1_1base__ReaderMNISTFile.html">base_ReaderMNISTFile</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">base class for reading MNIST files  <a href="classelm_1_1base__ReaderMNISTFile.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classelm_1_1ReadMNISTImages.html">ReadMNISTImages</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">class for Reading MNIST image data  <a href="classelm_1_1ReadMNISTImages.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classelm_1_1ReadMNISTImagesTransl.html">ReadMNISTImagesTransl</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classelm_1_1ReadMNISTLabels.html">ReadMNISTLabels</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">class for reading MNIST label data  <a href="classelm_1_1ReadMNISTLabels.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classelm_1_1AttentionWindow.html">AttentionWindow</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">layer for sampling patch around attended location (e.g.  <a href="classelm_1_1AttentionWindow.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classelm_1_1ConcatentateCloudXYZAndNormal.html">ConcatentateCloudXYZAndNormal</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classelm_1_1DiffOfGaussians.html">DiffOfGaussians</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Layer for difference of gaussians.  <a href="classelm_1_1DiffOfGaussians.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classelm_1_1GradAssignment.html">GradAssignment</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Layer for implementing Graduated Assignment algorithm for graph matching.  <a href="classelm_1_1GradAssignment.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classelm_1_1GraphCompatibility.html">GraphCompatibility</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classelm_1_1ICP.html">ICP</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">class for an iterative-closest-point layer This is basciallly a wrapper around PCL's <a class="el" href="classelm_1_1ICP.html" title="class for an iterative-closest-point layer This is basciallly a wrapper around PCL&#39;s ICP implementati...">ICP</a> implementation  <a href="classelm_1_1ICP.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classelm_1_1ImageGradient.html">ImageGradient</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Layer for computing image gradients using forward difference.  <a href="classelm_1_1ImageGradient.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classelm_1_1LayerY.html">LayerY</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">The <a class="el" href="classelm_1_1LayerY.html" title="The LayerY class.">LayerY</a> class.  <a href="classelm_1_1LayerY.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classelm_1_1LayerFactory.html">LayerFactory</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">class for implementing layer related factory methods Such as instantiation and sequencing of multiple layer applications (e.g.  <a href="classelm_1_1LayerFactory.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classelm_1_1LayerGraph.html">LayerGraph</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Layer <a class="el" href="classelm_1_1Graph.html" title="class for exposing public interface of Graph_Impl External face of Graph pimpl.">Graph</a> for managing non-linear layer pipelines.  <a href="classelm_1_1LayerGraph.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classelm_1_1LayerGraph__Impl.html">LayerGraph_Impl</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Layer <a class="el" href="classelm_1_1Graph.html" title="class for exposing public interface of Graph_Impl External face of Graph pimpl.">Graph</a> implentation for managing layer pipelines credit: J.  <a href="classelm_1_1LayerGraph__Impl.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classelm_1_1base__LayerNotSupported.html">base_LayerNotSupported</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">This is not an ordinary layer implementation This derived layer only aids in conditionally defined layers (i.e layers that are only supported if specific dependencies exist)  <a href="classelm_1_1base__LayerNotSupported.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classelm_1_1base__FeatureTransformationLayer.html">base_FeatureTransformationLayer</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">An intermediate base class for prviding a layer interface involving a transformation of a single input feature into a single output feature "1-1 stimulus to response transformation".  <a href="classelm_1_1base__FeatureTransformationLayer.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classelm_1_1base__FilterBankLayer.html">base_FilterBankLayer</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">base class for filter banks The interface should aid in iterating through response  <a href="classelm_1_1base__FilterBankLayer.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classelm_1_1base__LearningLayer.html">base_LearningLayer</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">class for defining interfaces of an abstract layer that can learn Overloaded constructor calls overloaded <a class="el" href="classelm_1_1base__Layer.html#a421520cd909add1589ff040764e952db" title="Reset the state of the layer with new configurations.">Reset()</a> so you can implement Reset(config) directly.  <a href="classelm_1_1base__LearningLayer.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classelm_1_1base__MatOutputLayer.html">base_MatOutputLayer</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">class for time-invariant layer  <a href="classelm_1_1base__MatOutputLayer.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classelm_1_1base__SingleInputFeatureLayer.html">base_SingleInputFeatureLayer</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">base class for layer assuming single feature input, an intermediate layer implementation  <a href="classelm_1_1base__SingleInputFeatureLayer.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classelm_1_1base__SmoothLayer.html">base_SmoothLayer</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">intermediate Layer for applying smoothing algorithms I/O keys already defined by parent class  <a href="classelm_1_1base__SmoothLayer.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classelm_1_1base__SparseMatOutputLayer.html">base_SparseMatOutputLayer</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">intermediate layer class assuming single sparse matrix output  <a href="classelm_1_1base__SparseMatOutputLayer.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classelm_1_1base__TIVLayer.html">base_TIVLayer</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">class for time-invariant layer  <a href="classelm_1_1base__TIVLayer.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classelm_1_1base__SupervisedBatch.html">base_SupervisedBatch</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">class for defining interfaces of an abstract layer that can learn Overloaded constructor calls overloaded <a class="el" href="classelm_1_1base__Layer.html#a421520cd909add1589ff040764e952db" title="Reset the state of the layer with new configurations.">Reset()</a> so you can implement Reset(config) directly.  <a href="classelm_1_1base__SupervisedBatch.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structelm_1_1LayerVertex.html">LayerVertex</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">wrap layer information to store as vertex  <a href="structelm_1_1LayerVertex.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classelm_1_1MedianBlur.html">MedianBlur</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Wrap layer around median blur input and output keys defined by parent.  <a href="classelm_1_1MedianBlur.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classelm_1_1MLP.html">MLP</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Layer class for mult-layer perceptrons.  <a href="classelm_1_1MLP.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classelm_1_1PointNormalEstimation.html">PointNormalEstimation</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Layer for estimating normals in point cloud.  <a href="classelm_1_1PointNormalEstimation.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classelm_1_1SaliencyItti.html">SaliencyItti</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Implement Itti et al.  <a href="classelm_1_1SaliencyItti.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classelm_1_1SinkhornBalancing.html">SinkhornBalancing</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Layer for implementing Singhorn's balancing algorithm.  <a href="classelm_1_1SinkhornBalancing.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classelm_1_1Triangulation.html">Triangulation</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">The triangulation layer wraps around the greedy projection algorithm usign pcl.  <a href="classelm_1_1Triangulation.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classelm_1_1WeightedSum.html">WeightedSum</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">class to implement base layer methods Yields weighted sum of stimulus with 2 elements Simple example on how to derive from <a class="el" href="classelm_1_1base__FeatureTransformationLayer.html" title="An intermediate base class for prviding a layer interface involving a transformation of a single inpu...">base_FeatureTransformationLayer</a> class  <a href="classelm_1_1WeightedSum.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classelm_1_1YNeuron.html">YNeuron</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">layer for trivial spiking neuron.  <a href="classelm_1_1YNeuron.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classelm_1_1FakeMNISTImagesWriter.html">FakeMNISTImagesWriter</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classelm_1_1FakeMNISTLabelsWriter.html">FakeMNISTLabelsWriter</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classelm_1_1Layer__TP__.html">Layer_TP_</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">A type-parameterized test case for repeating tests with different layer types.  <a href="classelm_1_1Layer__TP__.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classelm_1_1LayerInst__TP__.html">LayerInst_TP_</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">A type-parameterized test case for repeating tests with different layer types.  <a href="classelm_1_1LayerInst__TP__.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classelm_1_1LayerFeatTransf__TP__.html">LayerFeatTransf_TP_</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">A type-parameterized test case for repeating tests with different layer types derived from intermediate feature transfomation class.  <a href="classelm_1_1LayerFeatTransf__TP__.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structelm_1_1LayerAttr__.html">LayerAttr_</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Layer Attributes struct, a helper struct for layer p-typed test cases.  <a href="structelm_1_1LayerAttr__.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classelm_1_1LearningLayer__TP__.html">LearningLayer_TP_</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">A type-parameterized test case for repeating tests with different layer types.  <a href="classelm_1_1LearningLayer__TP__.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structelm_1_1FtV__.html">FtV_</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">the struct below, is a helper struct.  <a href="structelm_1_1FtV__.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classelm_1_1Signal__TP__.html">Signal_TP_</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">A setup for repeating tests with different types of mat objects (int, float, uchar)  <a href="classelm_1_1Signal__TP__.html#details">More...</a><br/></td></tr>
<tr><td colspan="2"><h2><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef boost::optional<br class="typebreak"/>
&lt; std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceelm.html#ac4548af7c6485d3354a27d70456a7162">OptS</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef boost::property<br class="typebreak"/>
&lt; boost::edge_weight_t, float &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceelm.html#af229d7c22d496805a8fac4c3fda653f1">EdgeWeightProperty</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef boost::adjacency_list<br class="typebreak"/>
&lt; boost::vecS, boost::vecS, <br class="typebreak"/>
boost::undirectedS, <br class="typebreak"/>
boost::no_property, <br class="typebreak"/>
<a class="el" href="namespaceelm.html#af229d7c22d496805a8fac4c3fda653f1">EdgeWeightProperty</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceelm.html#a9e8517342c6709a5b4aa6186040841d5">GraphType</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef boost::graph_traits<br class="typebreak"/>
&lt; <a class="el" href="namespaceelm.html#a9e8517342c6709a5b4aa6186040841d5">GraphType</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceelm.html#a5a81ee10318679c00daf55ce331e73fe">GraphTraits</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef GraphTraits::edge_iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceelm.html#af47fac1906fdb0695462fc80b1b39661">edge_iter</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceelm.html#aeb823f26e96bbaa7cf19ae85e0d125cc">EdgeWeight</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef boost::property<br class="typebreak"/>
&lt; boost::edge_weight_t, <br class="typebreak"/>
<a class="el" href="namespaceelm.html#aeb823f26e96bbaa7cf19ae85e0d125cc">EdgeWeight</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceelm.html#a49df45cad31254fdc5e7cb29dc984f59">EdgeWeightProp</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceelm.html#a67b382c4f27765dbb10e85e47ca27d04">VtxColor</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="namespacecv.html#a9747ac59f97cbb93ddd719c4fb3e2d5d">cv::Mat1f</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceelm.html#a0fe056d1afa48fefa80d496294a43c01">VtxIdx2</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef boost::property<br class="typebreak"/>
&lt; boost::vertex_color_t, <br class="typebreak"/>
<a class="el" href="namespaceelm.html#a67b382c4f27765dbb10e85e47ca27d04">VtxColor</a>, boost::property<br class="typebreak"/>
&lt; boost::vertex_index2_t, <br class="typebreak"/>
<a class="el" href="namespaceelm.html#a0fe056d1afa48fefa80d496294a43c01">VtxIdx2</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceelm.html#a2396f62943ed002804ccf6b846e41e5c">VtxProp</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef boost::adjacency_list<br class="typebreak"/>
&lt; boost::setS, boost::listS, <br class="typebreak"/>
boost::undirectedS, <a class="el" href="namespaceelm.html#a2396f62943ed002804ccf6b846e41e5c">VtxProp</a>, <br class="typebreak"/>
<a class="el" href="namespaceelm.html#a49df45cad31254fdc5e7cb29dc984f59">EdgeWeightProp</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceelm.html#a819a48c5fc3cc6ba32cd7338ecb1dbd5">GraphAttrType</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef boost::graph_traits<br class="typebreak"/>
&lt; <a class="el" href="namespaceelm.html#a819a48c5fc3cc6ba32cd7338ecb1dbd5">GraphAttrType</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceelm.html#a64bfc5f58d108181a3df91c64cd5b789">GraphAttrTraits</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef <br class="typebreak"/>
GraphAttrTraits::vertex_descriptor&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceelm.html#ad982cfe915f0437c796294b5f5cfe50a">VtxDescriptor</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef pcl::PointCloud<br class="typebreak"/>
&lt; pcl::PointXYZ &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceelm.html#a4b03e6e4ae44d64e4be85045fdacd080">CloudXYZ</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef boost::shared_ptr<br class="typebreak"/>
&lt; <a class="el" href="namespaceelm.html#a4b03e6e4ae44d64e4be85045fdacd080">CloudXYZ</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceelm.html#a628db60a685dbc3416270bd775fbc3de">CloudXYZPtr</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef pcl::PointCloud<br class="typebreak"/>
&lt; pcl::Normal &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceelm.html#a341e824e1ec81d89d69a6d7ae7681642">CloudNormal</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef boost::shared_ptr<br class="typebreak"/>
&lt; <a class="el" href="namespaceelm.html#a341e824e1ec81d89d69a6d7ae7681642">CloudNormal</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceelm.html#afcee1ba7a7815e9d3d46f2df89edc84c">CloudNrmlPtr</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef pcl::PointCloud<br class="typebreak"/>
&lt; pcl::PointNormal &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceelm.html#a6d1059521d47bb9f1aab825039f8eaef">CloudPtNrml</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef boost::shared_ptr<br class="typebreak"/>
&lt; <a class="el" href="namespaceelm.html#a6d1059521d47bb9f1aab825039f8eaef">CloudPtNrml</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceelm.html#a627286a25d331461a7dd634442751bec">CloudPtNrmlPtr</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef std::vector<br class="typebreak"/>
&lt; pcl::Vertices &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceelm.html#a920280bb0e893412086bdea6aa980e9d">VecVertices</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="namespaceelm.html#a920280bb0e893412086bdea6aa980e9d">VecVertices</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceelm.html#af423fcc1996e53e76f27f9b1cfecc18b">Triangles</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classelm_1_1Signal__.html">Signal_</a>&lt; <a class="el" href="classelm_1_1FeatureData.html">FeatureData</a> &gt;<br class="typebreak"/>
::VecFeat_&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceelm.html#ace809dc2b8adb6d45f63e036daaf1234">VecFeatData</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef std::vector&lt; std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceelm.html#acebbd34f9c41c07c407aca3a77311412">VecS</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef std::vector&lt; float &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceelm.html#aeb9b6f2a08544af2e9bf3524968a821e">VecF</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef std::vector&lt; int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceelm.html#a2682d98bd88471ad884834c91e3a520c">VecI</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef std::map&lt; std::string, <br class="typebreak"/>
std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceelm.html#a1ef23d8f68e89b761cfbfdb617b09f49">MapSS</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef cv::SparseMat_&lt; float &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceelm.html#a81bd2c792bb7bc6cbcd80d2d47978963">SparseMat1f</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef boost::property_tree::ptree&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceelm.html#ac280a058bfa7c9b6967bdae6031e3bf5">PTree</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef std::shared_ptr<br class="typebreak"/>
&lt; <a class="el" href="classelm_1_1base__Layer.html">base_Layer</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceelm.html#a45faaf73c009a4dcaf1438996550bfcc">LayerShared</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef std::vector&lt; <a class="el" href="namespacecv.html#a9747ac59f97cbb93ddd719c4fb3e2d5d">cv::Mat1f</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceelm.html#a984dca2f6ccfb930dd3cf2a6cf3c5fde">VecMat1f</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef std::vector&lt; cv::Mat &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceelm.html#a52449634df0718b5e216e44210563596">VecMat</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef std::set&lt; std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceelm.html#a3060bc7e1ebd113d390a4798290fc394">SetS</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef std::pair<br class="typebreak"/>
&lt; <a class="el" href="namespaceelm.html#ac5c73e977e493677f8bddc01b875db02">LayerIOKeyType</a>, std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceelm.html#ad02cf63865f194878427a1829f471da9">IOName</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef std::map&lt; std::string, <br class="typebreak"/>
<a class="el" href="namespaceelm.html#ad02cf63865f194878427a1829f471da9">IOName</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceelm.html#a2b8eb7cd84832a6a64c0da7dad94304a">MapIONames</a></td></tr>
<tr><td colspan="2"><h2><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceelm.html#ac5c73e977e493677f8bddc01b875db02">LayerIOKeyType</a> { <a class="el" href="namespaceelm.html#ac5c73e977e493677f8bddc01b875db02a545de7206d5b4db861ab95949110fa41">INPUT</a>, 
<a class="el" href="namespaceelm.html#ac5c73e977e493677f8bddc01b875db02a4ec4df54fa48cebdafa34d152f2ab55f">OUTPUT</a>
 }</td></tr>
<tr><td colspan="2"><h2><a name="func-members"></a>
Functions</h2></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">boost::python::list&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceelm.html#a12bddc1fe054e0e0110d9de3e49cc77c">toPythonList</a> (std::vector&lt; T &gt; v)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceelm.html#a9a21421295a964aca2593ad85b2798ac">UnusedNodes</a> (const <a class="el" href="namespaceelm.html#ac280a058bfa7c9b6967bdae6031e3bf5">PTree</a> &amp;p, const <a class="el" href="namespaceelm.html#acebbd34f9c41c07c407aca3a77311412">VecS</a> &amp;keys_used, <a class="el" href="namespaceelm.html#acebbd34f9c41c07c407aca3a77311412">VecS</a> &amp;keys_unused)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceelm.html#a6f5ac7f4d3c51fc096c16ccc1023faa5">PTreeToMapSS</a> (const <a class="el" href="namespaceelm.html#ac280a058bfa7c9b6967bdae6031e3bf5">PTree</a> &amp;src, <a class="el" href="namespaceelm.html#a1ef23d8f68e89b761cfbfdb617b09f49">MapSS</a> &amp;dst)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceelm.html#ae16129661373468d07f6a87c7600de66">MapSSToPTree</a> (const <a class="el" href="namespaceelm.html#a1ef23d8f68e89b761cfbfdb617b09f49">MapSS</a> &amp;src, <a class="el" href="namespaceelm.html#ac280a058bfa7c9b6967bdae6031e3bf5">PTree</a> &amp;dst)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceelm.html#add31de4aaf91a19fc02789189c47764e">PrintXML</a> (const <a class="el" href="namespaceelm.html#ac280a058bfa7c9b6967bdae6031e3bf5">PTree</a> &amp;pt, std::basic_ostream&lt; typename PTree::key_type::value_type &gt; &amp;stream)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceelm.html#a94639d3e188e5de0c37d47a620324c56">push_back_child</a> (const <a class="el" href="namespaceelm.html#ac280a058bfa7c9b6967bdae6031e3bf5">PTree</a> &amp;p, const std::string &amp;key, std::vector&lt; T &gt; &amp;v)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class Tarchive , class TElem &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceelm.html#ac20352760a019c40a2b3559fed186341">Save</a> (Tarchive &amp;ar, const cv::Mat_&lt; TElem &gt; &amp;obj)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class Tarchive , class TElem &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceelm.html#a7d050b2cbd04b01dab74e43818485b40">Load</a> (Tarchive &amp;ar, cv::Mat_&lt; TElem &gt; &amp;obj)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceelm.html#ab1cadb05efc348b5b0e59c39d744c0ff">GetVersion</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceelm.html#ad6facf27172e5a0d2db13d34cf4ab27f">MatTypeToString</a> (const cv::Mat &amp;m)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">cv::Mat_&lt; unsigned char &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceelm.html#a6e92e65b4ec4111e3ee01dfc1a3ded03">ConvertTo8U</a> (const cv::Mat &amp;src)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceelm.html#ab8475df4365d79afa3006ccdc7cd0c52">CumSum</a> (const <a class="el" href="namespacecv.html#a9747ac59f97cbb93ddd719c4fb3e2d5d">cv::Mat1f</a> &amp;src, <a class="el" href="namespacecv.html#a9747ac59f97cbb93ddd719c4fb3e2d5d">cv::Mat1f</a> &amp;dst)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceelm.html#ac7d91c0a0b9de95930ed7bba11b8e026">tril_flat</a> (const <a class="el" href="namespacecv.html#a9747ac59f97cbb93ddd719c4fb3e2d5d">cv::Mat1f</a> &amp;src, <a class="el" href="namespacecv.html#a9747ac59f97cbb93ddd719c4fb3e2d5d">cv::Mat1f</a> &amp;dst)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacecv.html#a9747ac59f97cbb93ddd719c4fb3e2d5d">cv::Mat1f</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceelm.html#af074d4ceef14f0102ce06b4367a732d2">diff</a> (const <a class="el" href="namespacecv.html#a9747ac59f97cbb93ddd719c4fb3e2d5d">cv::Mat1f</a> &amp;src, int n=1, int axis=-1)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacecv.html#a87332e283de569e7bb029d4f4b401dcc">cv::Mat1i</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceelm.html#a280dcde77b49b89660aea127c42ea9a8">Point2Mat</a> (const <a class="el" href="namespacecv.html#a0f70b52f0c0b119f7ed2448ffebdc144">cv::Point2i</a> &amp;p)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacecv.html#a0f70b52f0c0b119f7ed2448ffebdc144">cv::Point2i</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceelm.html#a61419ccc8ba498196ec3257f172acd7c">Mat2Point2i</a> (const <a class="el" href="namespacecv.html#a87332e283de569e7bb029d4f4b401dcc">cv::Mat1i</a> &amp;m)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">cv::Point3_&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceelm.html#a07d6cae24a269481639b6dc7677c7ba1">Mat2Point3_</a> (const cv::Mat_&lt; T &gt; &amp;m)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacecv.html#a87332e283de569e7bb029d4f4b401dcc">cv::Mat1i</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceelm.html#a05b0b20e2cc38b8881a5610ea56eaade">Rect2iToMat</a> (const <a class="el" href="namespacecv.html#aa87c8f580952d28b4127261994bce7d8">cv::Rect2i</a> &amp;r)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacecv.html#aa87c8f580952d28b4127261994bce7d8">cv::Rect2i</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceelm.html#ae0e1b7aaab323d6e21a2bda8d38468fe">MatToRect2i</a> (const <a class="el" href="namespacecv.html#a87332e283de569e7bb029d4f4b401dcc">cv::Mat1i</a> &amp;m)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacecv.html#ac705c6d749e0795c44314245643a55e0">cv::Mat1b</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceelm.html#a0086a6b2300114456b353753537a8ea1">isnan</a> (const <a class="el" href="namespacecv.html#a9747ac59f97cbb93ddd719c4fb3e2d5d">cv::Mat1f</a> &amp;src)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacecv.html#ac705c6d749e0795c44314245643a55e0">cv::Mat1b</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceelm.html#ae731b95db17713365266f645d4ff293c">is_not_nan</a> (const <a class="el" href="namespacecv.html#a9747ac59f97cbb93ddd719c4fb3e2d5d">cv::Mat1f</a> &amp;src)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceelm.html#aeebe2356ec3446a39abcaf5d09f731eb">find_first_of</a> (const cv::Mat &amp;m, const T &amp;<a class="el" href="binary_8h.html#ae7f66047e6e39ba2bb6af8b95f00d1dd">value</a>, int &amp;index=<a class="el" href="namespaceelm.html#a7713a3d419c89693eab7bf0f82f4540e">elm::NA_IDX</a>)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">cv::Mat_&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceelm.html#aba4d101c9dee988ae21a72c9b79ce2c4">ARange_</a> (T start, T stop, T step)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacecv.html#a9747ac59f97cbb93ddd719c4fb3e2d5d">cv::Mat1f</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceelm.html#a6212361bc80c580bc6061d1a583a8611">ElementsAt</a> (const <a class="el" href="namespaceelm.html#a984dca2f6ccfb930dd3cf2a6cf3c5fde">VecMat1f</a> &amp;v, int row, int col)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacecv.html#a9747ac59f97cbb93ddd719c4fb3e2d5d">cv::Mat1f</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceelm.html#ae5d005a6fd90d7a2b95e75c0cb5f651e">Reshape</a> (const <a class="el" href="namespaceelm.html#a984dca2f6ccfb930dd3cf2a6cf3c5fde">VecMat1f</a> &amp;v)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceelm.html#a9c7f94adefe67d3d18a48fff2bd7f1a4">tril</a> (const <a class="el" href="namespacecv.html#a9747ac59f97cbb93ddd719c4fb3e2d5d">cv::Mat1f</a> &amp;src, std::vector&lt; <a class="el" href="namespacecv.html#a9747ac59f97cbb93ddd719c4fb3e2d5d">cv::Mat1f</a> &gt; &amp;dst)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceelm.html#a83700a389d44a79354197cd9e7db179a">Mat_ToVec_</a> (const cv::Mat_&lt; T &gt; &amp;m)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">cv::Mat_&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceelm.html#adc7b5c3a1b48d23c88e688db04d452ea">Vec_ToRowMat_</a> (std::vector&lt; T &gt; &amp;v)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceelm.html#a189306ef4c8548b1f99b39fc445a0c7c">NeighMeanVar</a> (const <a class="el" href="namespacecv.html#a9747ac59f97cbb93ddd719c4fb3e2d5d">cv::Mat1f</a> &amp;m, int radius, <a class="el" href="namespacecv.html#a9747ac59f97cbb93ddd719c4fb3e2d5d">cv::Mat1f</a> &amp;neigh_mean, <a class="el" href="namespacecv.html#a9747ac59f97cbb93ddd719c4fb3e2d5d">cv::Mat1f</a> &amp;neigh_var, int border_type=cv::BORDER_REPLICATE, const cv::Scalar &amp;<a class="el" href="binary_8h.html#ae7f66047e6e39ba2bb6af8b95f00d1dd">value</a>=cv::Scalar())</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceelm.html#ace0198649e59df697bc14710d785ab27">total</a> (const cv::SparseMat &amp;m)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceelm.html#a4c9565cace7f9e79b2884fb1a0b8f7f8">CondEntropy</a> (cv::InputArray pdf)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceelm.html#a9ea7cc03476209de8d7d832a111c7cfd">operator&lt;&lt;</a> (std::ostream &amp;os, <a class="el" href="classelm_1_1FeatureData.html">FeatureData</a> &amp;obj)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceelm.html#aed7de6a12a8fe869a26365ea3e0a2dce">TriangulatedCloudToAdjacency</a> (const <a class="el" href="namespaceelm.html#a628db60a685dbc3416270bd775fbc3de">CloudXYZPtr</a> &amp;cld, const <a class="el" href="namespaceelm.html#af423fcc1996e53e76f27f9b1cfecc18b">Triangles</a> &amp;t, <a class="el" href="namespacecv.html#a9747ac59f97cbb93ddd719c4fb3e2d5d">cv::Mat1f</a> &amp;dst)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceelm.html#a69b3ed95dc7d8a85b72cdb15c5313131">TriangulatedCloudToAdjacency</a> (const <a class="el" href="namespaceelm.html#a628db60a685dbc3416270bd775fbc3de">CloudXYZPtr</a> &amp;cld, const <a class="el" href="namespaceelm.html#af423fcc1996e53e76f27f9b1cfecc18b">Triangles</a> &amp;t, <a class="el" href="namespaceelm.html#a81bd2c792bb7bc6cbcd80d2d47978963">elm::SparseMat1f</a> &amp;dst)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class TPoint &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">boost::shared_ptr<br class="typebreak"/>
&lt; pcl::PointCloud&lt; TPoint &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceelm.html#a51484199ba2c17f38e34678f33821e62">Mat2PointCloud_</a> (const <a class="el" href="namespacecv.html#a9747ac59f97cbb93ddd719c4fb3e2d5d">cv::Mat1f</a> &amp;m)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class TPoint &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacecv.html#a9747ac59f97cbb93ddd719c4fb3e2d5d">cv::Mat1f</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceelm.html#a3bb5480fb3881faf63af4a429a8d0a4c">PointCloud2Mat_</a> (boost::shared_ptr&lt; pcl::PointCloud&lt; TPoint &gt; &gt; &amp;cloud_ptr)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacecv.html#a9747ac59f97cbb93ddd719c4fb3e2d5d">cv::Mat1f</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceelm.html#a0985d63df87c4447864e729ad0f84519">TriangleEdges</a> (const pcl::PointXYZ &amp;p0, const pcl::PointXYZ &amp;p1, const pcl::PointXYZ &amp;p2)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceelm.html#a920280bb0e893412086bdea6aa980e9d">VecVertices</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceelm.html#a45180339ab7fe4e54b975a589b590424">Mat2VecVertices</a> (const cv::Mat &amp;m)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacecv.html#a9747ac59f97cbb93ddd719c4fb3e2d5d">cv::Mat1f</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceelm.html#abf4cc23596a9d94b46c1c482507777f8">VecVertices2Mat</a> (const <a class="el" href="namespaceelm.html#a920280bb0e893412086bdea6aa980e9d">VecVertices</a> &amp;vv, bool do_row_mat=true)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceelm.html#a8824e803fe2c2743750c37e4216f6cff">randexp</a> (float lambda)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceelm.html#ade130b3139af2a820c2215b6a8eafbfc">Find</a> (const std::map&lt; std::string, T &gt; &amp;map, const std::string &amp;key, T &amp;obj)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class TKey , class TVal &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; TKey &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceelm.html#a639456db50fb0568bf034200fee2c8e4">Keys</a> (const std::map&lt; TKey, TVal &gt; &amp;m)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class TKey , class TVal &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; TVal &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceelm.html#add56d0ab3d62df55c40e0d6dc94eb0c2">Values</a> (const std::map&lt; TKey, TVal &gt; &amp;m)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceelm.html#a0e9eb99fe59b32ea73813ffac64ad47b">push_back_randu</a> (std::vector&lt; T &gt; &amp;v, int N)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">std::string&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceelm.html#a8a54b057b1c7ddd03aee880f47d21254">to_string</a> (const std::vector&lt; T &gt; &amp;v, const std::string &amp;delim=&quot;, &quot;)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceelm.html#a6b28c339e53f53455b44833735a5fc69">SwapEndian</a> (T *p)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceelm.html#a717ced0dc6520c7f3b01fdef963cdfdd">Save</a> (const boost::filesystem::path &amp;p, const T &amp;obj)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceelm.html#a4261bafcd535e25627304fa2c8528075">Load</a> (const boost::filesystem::path &amp;p, T &amp;obj)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">int&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceelm.html#a201610be6b9b06901bb3ae0d5da92e1d">LayerGraph::Reconfigure&lt; std::string &gt;</a> (const std::string &amp;key, const std::string &amp;<a class="el" href="binary_8h.html#ae7f66047e6e39ba2bb6af8b95f00d1dd">value</a>)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceelm.html#a5bd71c1c7a75aa859e6993988e5ab3b9">InitializeIONames</a> (const <a class="el" href="namespaceelm.html#a2b8eb7cd84832a6a64c0da7dad94304a">MapIONames</a> &amp;io_pairs, const <a class="el" href="namespaceelm.html#acebbd34f9c41c07c407aca3a77311412">VecS</a> &amp;keys, <a class="el" href="classelm_1_1LayerIONames.html">LayerIONames</a> &amp;dst)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceelm.html#a015533ce3549f34ea2026d72abb9602f">TYPED_TEST_CASE_P</a> (<a class="el" href="classelm_1_1Layer__TP__.html">Layer_TP_</a>)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceelm.html#a8fc46887c8ceea0bd74418f1e8e4f91e">TYPED_TEST_P</a> (<a class="el" href="classelm_1_1Layer__TP__.html">Layer_TP_</a>, Clear)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceelm.html#a3eccaf7c9e3d0c8739eea9d8baab6c6a">TYPED_TEST_P</a> (<a class="el" href="classelm_1_1Layer__TP__.html">Layer_TP_</a>, Constructor)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceelm.html#ad286e64ff4863a7b12e668c34f119ae1">TYPED_TEST_P</a> (<a class="el" href="classelm_1_1Layer__TP__.html">Layer_TP_</a>, Destructor)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceelm.html#a1dfd708f0bccb272e62cdca11c36e27c">TYPED_TEST_P</a> (<a class="el" href="classelm_1_1Layer__TP__.html">Layer_TP_</a>, RequiredIONamesValidation)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceelm.html#a1a6d6179436fe5c4bc9b95a77f881afa">REGISTER_TYPED_TEST_CASE_P</a> (<a class="el" href="classelm_1_1Layer__TP__.html">Layer_TP_</a>, Clear, Constructor, Destructor, RequiredIONamesValidation)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceelm.html#a29068155c7097bf9813d4741f90886a0">TYPED_TEST_CASE_P</a> (<a class="el" href="classelm_1_1LayerInst__TP__.html">LayerInst_TP_</a>)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceelm.html#a4e2bbacb78892b72392100b3ddf1303b">TYPED_TEST_P</a> (<a class="el" href="classelm_1_1LayerInst__TP__.html">LayerInst_TP_</a>, Clear)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceelm.html#ab9a73cb21deafd7ea31f9dd508d32328">TYPED_TEST_P</a> (<a class="el" href="classelm_1_1LayerInst__TP__.html">LayerInst_TP_</a>, Constructor)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceelm.html#a4c45786c87f54db7abf377c2f57c9335">TYPED_TEST_P</a> (<a class="el" href="classelm_1_1LayerInst__TP__.html">LayerInst_TP_</a>, Destructor)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceelm.html#a98a416c3b2ed4e0bc00a83bebf67c283">REGISTER_TYPED_TEST_CASE_P</a> (<a class="el" href="classelm_1_1LayerInst__TP__.html">LayerInst_TP_</a>, Clear, Constructor, Destructor)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceelm.html#a90670dbb4ab62053e01380f9dfbfb74e">TYPED_TEST_CASE_P</a> (<a class="el" href="classelm_1_1LayerFeatTransf__TP__.html">LayerFeatTransf_TP_</a>)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceelm.html#ac47226acf23833bc7b73435787a3d2f9">TYPED_TEST_P</a> (<a class="el" href="classelm_1_1LayerFeatTransf__TP__.html">LayerFeatTransf_TP_</a>, Response_exists)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceelm.html#acb5d5e63b71842548f0ee4894b42cd90">REGISTER_TYPED_TEST_CASE_P</a> (<a class="el" href="classelm_1_1LayerFeatTransf__TP__.html">LayerFeatTransf_TP_</a>, Response_exists)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceelm.html#a2759bdbeb316e08156832cd75d0dbd4c">TYPED_TEST_CASE_P</a> (<a class="el" href="classelm_1_1LearningLayer__TP__.html">LearningLayer_TP_</a>)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceelm.html#a7e5152d8dd0e56997f05071b15c27e50">TYPED_TEST_P</a> (<a class="el" href="classelm_1_1LearningLayer__TP__.html">LearningLayer_TP_</a>, Clear)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceelm.html#aa45bd11895cf9bf124dfc0f56fe46e20">TYPED_TEST_P</a> (<a class="el" href="classelm_1_1LearningLayer__TP__.html">LearningLayer_TP_</a>, Constructor)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceelm.html#ab574c73fc410b80fba460fa9a0ab212d">TYPED_TEST_P</a> (<a class="el" href="classelm_1_1LearningLayer__TP__.html">LearningLayer_TP_</a>, Destructor)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceelm.html#a05c2f8d7413febd82d4d3b0084bab782">REGISTER_TYPED_TEST_CASE_P</a> (<a class="el" href="classelm_1_1LearningLayer__TP__.html">LearningLayer_TP_</a>, Clear, Constructor, Destructor)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceelm.html#a9927386e25635c2fa52b52fa26cfdb37">TYPED_TEST_CASE_P</a> (<a class="el" href="classelm_1_1Signal__TP__.html">Signal_TP_</a>)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceelm.html#a77b6e5d6e1ae2c4907ae675abb8313bc">TYPED_TEST_P</a> (<a class="el" href="classelm_1_1Signal__TP__.html">Signal_TP_</a>, Constructor)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceelm.html#a2f3a3b9c116e9fbe6dfd1ce5aec5ea33">TYPED_TEST_P</a> (<a class="el" href="classelm_1_1Signal__TP__.html">Signal_TP_</a>, Clear)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceelm.html#a071ae502cb284731ccacf397cf3c341a">TYPED_TEST_P</a> (<a class="el" href="classelm_1_1Signal__TP__.html">Signal_TP_</a>, FeatureNames)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceelm.html#a9c0e97a9c65088b9a52483302c5691e6">TYPED_TEST_P</a> (<a class="el" href="classelm_1_1Signal__TP__.html">Signal_TP_</a>, GetFeatures)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceelm.html#a0fa6c211bdd07b39e09a6465794017d3">TYPED_TEST_P</a> (<a class="el" href="classelm_1_1Signal__TP__.html">Signal_TP_</a>, MostRecent_Invalid)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceelm.html#af631c11309d8ad43f0447acd9107c6f2">TYPED_TEST_P</a> (<a class="el" href="classelm_1_1Signal__TP__.html">Signal_TP_</a>, Append)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceelm.html#a6604dc775bb2f33aba89680ef1056795">TYPED_TEST_P</a> (<a class="el" href="classelm_1_1Signal__TP__.html">Signal_TP_</a>, MostRecent_after_Append)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceelm.html#aeb4692dee32b0177db74beb68014ed2e">REGISTER_TYPED_TEST_CASE_P</a> (<a class="el" href="classelm_1_1Signal__TP__.html">Signal_TP_</a>, Constructor, Clear, FeatureNames, GetFeatures, MostRecent_Invalid, Append, MostRecent_after_Append)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceelm.html#a86b2edbd0f0d421ddbd35d79d242a439">FullTestName</a> (const ::testing::TestInfo *test_info)</td></tr>
<tr><td colspan="2"><h2><a name="var-members"></a>
Variables</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceelm.html#a7713a3d419c89693eab7bf0f82f4540e">NA_IDX</a></td></tr>
</table>
<hr/><a name="details" id="details"></a><h2>Detailed Description</h2>
<div class="textblock"><p>Non-template utility definitions For template inline definitions see *_inl*. </p>
<p>Include this header to include other headers with.</p>
<p>Setting up type-parameterized tests for <a class="el" href="classelm_1_1Signal__.html" title="The template Signal class, a class for holding single and multiple samples of features.">Signal_</a> template class To subscribe to these tests for your dervied template of <a class="el" href="classelm_1_1Signal__.html" title="The template Signal class, a class for holding single and multiple samples of features.">Signal_</a>:</p>
<p>forward declarations of STL data types</p>
<ul>
<li>Include this header.</li>
<li>Add to you unit test source file: typedef ::testing::Types&lt;int, <a class="el" href="namespacecv.html#a9747ac59f97cbb93ddd719c4fb3e2d5d" title="convinience typedef for Mat of floats without constraints on no. of channels">cv::Mat1f</a>, ...&gt; SignalFeatType; INSTANTIATE_TYPED_TEST_CASE_P(UniqueTestCollectionName, Signal_TP_, SignalFeatType); OR if it's only a single type, you can do: INSTANTIATE_TYPED_TEST_CASE_P(UniqueTestCollectionName, Signal_TP_, int);</li>
</ul>
<ul>
<li>Initalize V_ with 3 values for each of your type, please check value usage in test case' SetUP() and fixtures below:</li>
<li>It is important to stay consistent with the logic in the tests that make use of these values. Example: template&lt;&gt; std::vector&lt;int&gt; V_&lt;int&gt;::values{0, 1, 100}; template&lt;&gt; std::vector&lt;cv::Mat1f &gt; V_&lt; cv::Mat1f &gt;::values{Mat1f(1, 1, 0.f), Mat1f(1, 1, 1.f), Mat1f(1, 1, 100.f)};</li>
</ul>
<p>for more details, please see: <a href="https://code.google.com/p/googletest/wiki/AdvancedGuide#Type-Parameterized_Tests">https://code.google.com/p/googletest/wiki/AdvancedGuide#Type-Parameterized_Tests</a></p>
<ul>
<li>custom assertions</li>
<li>test-related routines Don't forget to add new headers as you create them </li>
</ul>
</div><hr/><h2>Typedef Documentation</h2>
<a class="anchor" id="a341e824e1ec81d89d69a6d7ae7681642"></a><!-- doxytag: member="elm::CloudNormal" ref="a341e824e1ec81d89d69a6d7ae7681642" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef pcl::PointCloud&lt;pcl::Normal&gt; <a class="el" href="namespaceelm.html#a341e824e1ec81d89d69a6d7ae7681642">elm::CloudNormal</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="pcl_2typedefs__fwd_8h_source.html#l00038">38</a> of file <a class="el" href="pcl_2typedefs__fwd_8h_source.html">pcl/typedefs_fwd.h</a>.</p>

</div>
</div>
<a class="anchor" id="afcee1ba7a7815e9d3d46f2df89edc84c"></a><!-- doxytag: member="elm::CloudNrmlPtr" ref="afcee1ba7a7815e9d3d46f2df89edc84c" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef boost::shared_ptr&lt;<a class="el" href="namespaceelm.html#a341e824e1ec81d89d69a6d7ae7681642">CloudNormal</a> &gt; <a class="el" href="namespaceelm.html#afcee1ba7a7815e9d3d46f2df89edc84c">elm::CloudNrmlPtr</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="pcl_2typedefs__fwd_8h_source.html#l00040">40</a> of file <a class="el" href="pcl_2typedefs__fwd_8h_source.html">pcl/typedefs_fwd.h</a>.</p>

</div>
</div>
<a class="anchor" id="a6d1059521d47bb9f1aab825039f8eaef"></a><!-- doxytag: member="elm::CloudPtNrml" ref="a6d1059521d47bb9f1aab825039f8eaef" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef pcl::PointCloud&lt;pcl::PointNormal&gt; <a class="el" href="namespaceelm.html#a6d1059521d47bb9f1aab825039f8eaef">elm::CloudPtNrml</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="pcl_2typedefs__fwd_8h_source.html#l00042">42</a> of file <a class="el" href="pcl_2typedefs__fwd_8h_source.html">pcl/typedefs_fwd.h</a>.</p>

</div>
</div>
<a class="anchor" id="a627286a25d331461a7dd634442751bec"></a><!-- doxytag: member="elm::CloudPtNrmlPtr" ref="a627286a25d331461a7dd634442751bec" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef boost::shared_ptr&lt;<a class="el" href="namespaceelm.html#a6d1059521d47bb9f1aab825039f8eaef">CloudPtNrml</a> &gt; <a class="el" href="namespaceelm.html#a627286a25d331461a7dd634442751bec">elm::CloudPtNrmlPtr</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="pcl_2typedefs__fwd_8h_source.html#l00044">44</a> of file <a class="el" href="pcl_2typedefs__fwd_8h_source.html">pcl/typedefs_fwd.h</a>.</p>

</div>
</div>
<a class="anchor" id="a4b03e6e4ae44d64e4be85045fdacd080"></a><!-- doxytag: member="elm::CloudXYZ" ref="a4b03e6e4ae44d64e4be85045fdacd080" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef pcl::PointCloud&lt;pcl::PointXYZ&gt; <a class="el" href="namespaceelm.html#a4b03e6e4ae44d64e4be85045fdacd080">elm::CloudXYZ</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="pcl_2typedefs__fwd_8h_source.html#l00034">34</a> of file <a class="el" href="pcl_2typedefs__fwd_8h_source.html">pcl/typedefs_fwd.h</a>.</p>

</div>
</div>
<a class="anchor" id="a628db60a685dbc3416270bd775fbc3de"></a><!-- doxytag: member="elm::CloudXYZPtr" ref="a628db60a685dbc3416270bd775fbc3de" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef boost::shared_ptr&lt;<a class="el" href="namespaceelm.html#a4b03e6e4ae44d64e4be85045fdacd080">CloudXYZ</a> &gt; <a class="el" href="namespaceelm.html#a628db60a685dbc3416270bd775fbc3de">elm::CloudXYZPtr</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="pcl_2typedefs__fwd_8h_source.html#l00036">36</a> of file <a class="el" href="pcl_2typedefs__fwd_8h_source.html">pcl/typedefs_fwd.h</a>.</p>

</div>
</div>
<a class="anchor" id="af47fac1906fdb0695462fc80b1b39661"></a><!-- doxytag: member="elm::edge_iter" ref="af47fac1906fdb0695462fc80b1b39661" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef GraphAttrTraits::edge_iterator <a class="el" href="namespaceelm.html#af47fac1906fdb0695462fc80b1b39661">elm::edge_iter</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="graph__impl_8h_source.html#l00026">26</a> of file <a class="el" href="graph__impl_8h_source.html">graph_impl.h</a>.</p>

</div>
</div>
<a class="anchor" id="aeb823f26e96bbaa7cf19ae85e0d125cc"></a><!-- doxytag: member="elm::EdgeWeight" ref="aeb823f26e96bbaa7cf19ae85e0d125cc" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef float <a class="el" href="namespaceelm.html#aeb823f26e96bbaa7cf19ae85e0d125cc">elm::EdgeWeight</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="graphattr__impl__typedefs_8h_source.html#l00022">22</a> of file <a class="el" href="graphattr__impl__typedefs_8h_source.html">graphattr_impl_typedefs.h</a>.</p>

</div>
</div>
<a class="anchor" id="a49df45cad31254fdc5e7cb29dc984f59"></a><!-- doxytag: member="elm::EdgeWeightProp" ref="a49df45cad31254fdc5e7cb29dc984f59" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef boost::property&lt;boost::edge_weight_t, <a class="el" href="namespaceelm.html#aeb823f26e96bbaa7cf19ae85e0d125cc">EdgeWeight</a>&gt; <a class="el" href="namespaceelm.html#a49df45cad31254fdc5e7cb29dc984f59">elm::EdgeWeightProp</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="graphattr__impl__typedefs_8h_source.html#l00023">23</a> of file <a class="el" href="graphattr__impl__typedefs_8h_source.html">graphattr_impl_typedefs.h</a>.</p>

</div>
</div>
<a class="anchor" id="af229d7c22d496805a8fac4c3fda653f1"></a><!-- doxytag: member="elm::EdgeWeightProperty" ref="af229d7c22d496805a8fac4c3fda653f1" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef boost::property&lt;boost::edge_weight_t, float&gt; <a class="el" href="namespaceelm.html#af229d7c22d496805a8fac4c3fda653f1">elm::EdgeWeightProperty</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="graph__impl_8h_source.html#l00023">23</a> of file <a class="el" href="graph__impl_8h_source.html">graph_impl.h</a>.</p>

</div>
</div>
<a class="anchor" id="a64bfc5f58d108181a3df91c64cd5b789"></a><!-- doxytag: member="elm::GraphAttrTraits" ref="a64bfc5f58d108181a3df91c64cd5b789" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef boost::graph_traits&lt;<a class="el" href="namespaceelm.html#a819a48c5fc3cc6ba32cd7338ecb1dbd5">GraphAttrType</a>&gt; <a class="el" href="namespaceelm.html#a64bfc5f58d108181a3df91c64cd5b789">elm::GraphAttrTraits</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="graphattr__impl__typedefs_8h_source.html#l00033">33</a> of file <a class="el" href="graphattr__impl__typedefs_8h_source.html">graphattr_impl_typedefs.h</a>.</p>

</div>
</div>
<a class="anchor" id="a819a48c5fc3cc6ba32cd7338ecb1dbd5"></a><!-- doxytag: member="elm::GraphAttrType" ref="a819a48c5fc3cc6ba32cd7338ecb1dbd5" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef boost::adjacency_list&lt;boost::setS, boost::listS, boost::undirectedS, <a class="el" href="namespaceelm.html#a2396f62943ed002804ccf6b846e41e5c">VtxProp</a>, <a class="el" href="namespaceelm.html#a49df45cad31254fdc5e7cb29dc984f59">EdgeWeightProp</a>&gt; <a class="el" href="namespaceelm.html#a819a48c5fc3cc6ba32cd7338ecb1dbd5">elm::GraphAttrType</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="graphattr__impl__typedefs_8h_source.html#l00031">31</a> of file <a class="el" href="graphattr__impl__typedefs_8h_source.html">graphattr_impl_typedefs.h</a>.</p>

</div>
</div>
<a class="anchor" id="a5a81ee10318679c00daf55ce331e73fe"></a><!-- doxytag: member="elm::GraphTraits" ref="a5a81ee10318679c00daf55ce331e73fe" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef boost::graph_traits&lt;<a class="el" href="namespaceelm.html#a9e8517342c6709a5b4aa6186040841d5">GraphType</a>&gt; <a class="el" href="namespaceelm.html#a5a81ee10318679c00daf55ce331e73fe">elm::GraphTraits</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="graph__impl_8h_source.html#l00025">25</a> of file <a class="el" href="graph__impl_8h_source.html">graph_impl.h</a>.</p>

</div>
</div>
<a class="anchor" id="a9e8517342c6709a5b4aa6186040841d5"></a><!-- doxytag: member="elm::GraphType" ref="a9e8517342c6709a5b4aa6186040841d5" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef boost::adjacency_list&lt;boost::vecS, boost::vecS, boost::undirectedS, boost::no_property, <a class="el" href="namespaceelm.html#af229d7c22d496805a8fac4c3fda653f1">EdgeWeightProperty</a>&gt; <a class="el" href="namespaceelm.html#a9e8517342c6709a5b4aa6186040841d5">elm::GraphType</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="graph__impl_8h_source.html#l00024">24</a> of file <a class="el" href="graph__impl_8h_source.html">graph_impl.h</a>.</p>

</div>
</div>
<a class="anchor" id="ad02cf63865f194878427a1829f471da9"></a><!-- doxytag: member="elm::IOName" ref="ad02cf63865f194878427a1829f471da9" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef std::pair&lt;<a class="el" href="namespaceelm.html#ac5c73e977e493677f8bddc01b875db02">LayerIOKeyType</a>, std::string&gt; <a class="el" href="namespaceelm.html#ad02cf63865f194878427a1829f471da9">elm::IOName</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>convinience typedef to layer io name with bool indicating input (0) or output (1) </p>

<p>Definition at line <a class="el" href="layerattr___8h_source.html#l00028">28</a> of file <a class="el" href="layerattr___8h_source.html">layerattr_.h</a>.</p>

</div>
</div>
<a class="anchor" id="a45faaf73c009a4dcaf1438996550bfcc"></a><!-- doxytag: member="elm::LayerShared" ref="a45faaf73c009a4dcaf1438996550bfcc" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef std::shared_ptr&lt;<a class="el" href="classelm_1_1base__Layer.html">base_Layer</a>&gt; <a class="el" href="namespaceelm.html#a45faaf73c009a4dcaf1438996550bfcc">elm::LayerShared</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="typedefs__fwd_8h_source.html#l00036">36</a> of file <a class="el" href="typedefs__fwd_8h_source.html">typedefs_fwd.h</a>.</p>

</div>
</div>
<a class="anchor" id="a2b8eb7cd84832a6a64c0da7dad94304a"></a><!-- doxytag: member="elm::MapIONames" ref="a2b8eb7cd84832a6a64c0da7dad94304a" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef std::map&lt; std::string, <a class="el" href="namespaceelm.html#ad02cf63865f194878427a1829f471da9">IOName</a> &gt; <a class="el" href="namespaceelm.html#a2b8eb7cd84832a6a64c0da7dad94304a">elm::MapIONames</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>convinience typedef for a map of io keys and corresponding io name </p>

<p>Definition at line <a class="el" href="layerattr___8h_source.html#l00032">32</a> of file <a class="el" href="layerattr___8h_source.html">layerattr_.h</a>.</p>

</div>
</div>
<a class="anchor" id="a1ef23d8f68e89b761cfbfdb617b09f49"></a><!-- doxytag: member="elm::MapSS" ref="a1ef23d8f68e89b761cfbfdb617b09f49" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef std::map&lt;std::string, std::string&gt; <a class="el" href="namespaceelm.html#a1ef23d8f68e89b761cfbfdb617b09f49">elm::MapSS</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Convinience typedef for map of string keys and string values. </p>

<p>Definition at line <a class="el" href="stl_2typedefs_8h_source.html#l00022">22</a> of file <a class="el" href="stl_2typedefs_8h_source.html">stl/typedefs.h</a>.</p>

</div>
</div>
<a class="anchor" id="ac4548af7c6485d3354a27d70456a7162"></a><!-- doxytag: member="elm::OptS" ref="ac4548af7c6485d3354a27d70456a7162" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef boost::optional&lt;std::string&gt; <a class="el" href="namespaceelm.html#ac4548af7c6485d3354a27d70456a7162">elm::OptS</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Convinience typedef for optional string. </p>

<p>Definition at line <a class="el" href="boost_2typedefs__sfwd_8h_source.html#l00019">19</a> of file <a class="el" href="boost_2typedefs__sfwd_8h_source.html">boost/typedefs_sfwd.h</a>.</p>

</div>
</div>
<a class="anchor" id="ac280a058bfa7c9b6967bdae6031e3bf5"></a><!-- doxytag: member="elm::PTree" ref="ac280a058bfa7c9b6967bdae6031e3bf5" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef boost::property_tree::ptree <a class="el" href="namespaceelm.html#ac280a058bfa7c9b6967bdae6031e3bf5">elm::PTree</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="typedefs__fwd_8h_source.html#l00032">32</a> of file <a class="el" href="typedefs__fwd_8h_source.html">typedefs_fwd.h</a>.</p>

</div>
</div>
<a class="anchor" id="a3060bc7e1ebd113d390a4798290fc394"></a><!-- doxytag: member="elm::SetS" ref="a3060bc7e1ebd113d390a4798290fc394" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef std::set&lt; std::string &gt; <a class="el" href="namespaceelm.html#a3060bc7e1ebd113d390a4798290fc394">elm::SetS</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>convinience typedef for set of strings </p>

<p>Definition at line <a class="el" href="layergraph_8h_source.html#l00020">20</a> of file <a class="el" href="layergraph_8h_source.html">layergraph.h</a>.</p>

</div>
</div>
<a class="anchor" id="a81bd2c792bb7bc6cbcd80d2d47978963"></a><!-- doxytag: member="elm::SparseMat1f" ref="a81bd2c792bb7bc6cbcd80d2d47978963" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef cv::SparseMat_&lt;float&gt; <a class="el" href="namespaceelm.html#a81bd2c792bb7bc6cbcd80d2d47978963">elm::SparseMat1f</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>convinience forward typedef for Mat of floats without constraints on no. of channels </p>

<p>Definition at line <a class="el" href="typedefs__fwd_8h_source.html#l00030">30</a> of file <a class="el" href="typedefs__fwd_8h_source.html">typedefs_fwd.h</a>.</p>

</div>
</div>
<a class="anchor" id="af423fcc1996e53e76f27f9b1cfecc18b"></a><!-- doxytag: member="elm::Triangles" ref="af423fcc1996e53e76f27f9b1cfecc18b" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="namespaceelm.html#a920280bb0e893412086bdea6aa980e9d">VecVertices</a> <a class="el" href="namespaceelm.html#af423fcc1996e53e76f27f9b1cfecc18b">elm::Triangles</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="pcl_2typedefs__fwd_8h_source.html#l00048">48</a> of file <a class="el" href="pcl_2typedefs__fwd_8h_source.html">pcl/typedefs_fwd.h</a>.</p>

</div>
</div>
<a class="anchor" id="aeb9b6f2a08544af2e9bf3524968a821e"></a><!-- doxytag: member="elm::VecF" ref="aeb9b6f2a08544af2e9bf3524968a821e" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef std::vector&lt; float &gt; <a class="el" href="namespaceelm.html#aeb9b6f2a08544af2e9bf3524968a821e">elm::VecF</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Convinience typedef for vector of floats. </p>

<p>Definition at line <a class="el" href="stl_2typedefs_8h_source.html#l00020">20</a> of file <a class="el" href="stl_2typedefs_8h_source.html">stl/typedefs.h</a>.</p>

</div>
</div>
<a class="anchor" id="ace809dc2b8adb6d45f63e036daaf1234"></a><!-- doxytag: member="elm::VecFeatData" ref="ace809dc2b8adb6d45f63e036daaf1234" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classelm_1_1Signal__.html">Signal_</a>&lt;<a class="el" href="classelm_1_1FeatureData.html">FeatureData</a> &gt;::VecFeat_ <a class="el" href="namespaceelm.html#ace809dc2b8adb6d45f63e036daaf1234">elm::VecFeatData</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>convinience typedef for vector of <a class="el" href="classelm_1_1FeatureData.html" title="The Feature data class.">FeatureData</a> objects </p>

<p>Definition at line <a class="el" href="signal__impl_8h_source.html#l00018">18</a> of file <a class="el" href="signal__impl_8h_source.html">signal_impl.h</a>.</p>

</div>
</div>
<a class="anchor" id="a2682d98bd88471ad884834c91e3a520c"></a><!-- doxytag: member="elm::VecI" ref="a2682d98bd88471ad884834c91e3a520c" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef std::vector&lt; int &gt; <a class="el" href="namespaceelm.html#a2682d98bd88471ad884834c91e3a520c">elm::VecI</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Convinience typedef for vector of integers. </p>

<p>Definition at line <a class="el" href="stl_2typedefs_8h_source.html#l00021">21</a> of file <a class="el" href="stl_2typedefs_8h_source.html">stl/typedefs.h</a>.</p>

</div>
</div>
<a class="anchor" id="a52449634df0718b5e216e44210563596"></a><!-- doxytag: member="elm::VecMat" ref="a52449634df0718b5e216e44210563596" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef std::vector&lt; cv::Mat &gt; <a class="el" href="namespaceelm.html#a52449634df0718b5e216e44210563596">elm::VecMat</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Convinience typedef for vector of matrices. </p>

<p>Definition at line <a class="el" href="typedefs__sfwd_8h_source.html#l00020">20</a> of file <a class="el" href="typedefs__sfwd_8h_source.html">typedefs_sfwd.h</a>.</p>

</div>
</div>
<a class="anchor" id="a984dca2f6ccfb930dd3cf2a6cf3c5fde"></a><!-- doxytag: member="elm::VecMat1f" ref="a984dca2f6ccfb930dd3cf2a6cf3c5fde" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef std::vector&lt; <a class="el" href="namespacecv.html#a9747ac59f97cbb93ddd719c4fb3e2d5d">cv::Mat1f</a> &gt; <a class="el" href="namespaceelm.html#a984dca2f6ccfb930dd3cf2a6cf3c5fde">elm::VecMat1f</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Convinience typedef for vector of single channel float matrices. </p>

<p>Definition at line <a class="el" href="typedefs__sfwd_8h_source.html#l00019">19</a> of file <a class="el" href="typedefs__sfwd_8h_source.html">typedefs_sfwd.h</a>.</p>

</div>
</div>
<a class="anchor" id="acebbd34f9c41c07c407aca3a77311412"></a><!-- doxytag: member="elm::VecS" ref="acebbd34f9c41c07c407aca3a77311412" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef std::vector&lt; std::string &gt; <a class="el" href="namespaceelm.html#acebbd34f9c41c07c407aca3a77311412">elm::VecS</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Convinience typedef for vector of strings. </p>

<p>Definition at line <a class="el" href="stl_2typedefs_8h_source.html#l00019">19</a> of file <a class="el" href="stl_2typedefs_8h_source.html">stl/typedefs.h</a>.</p>

</div>
</div>
<a class="anchor" id="a920280bb0e893412086bdea6aa980e9d"></a><!-- doxytag: member="elm::VecVertices" ref="a920280bb0e893412086bdea6aa980e9d" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef std::vector&lt;pcl::Vertices &gt; <a class="el" href="namespaceelm.html#a920280bb0e893412086bdea6aa980e9d">elm::VecVertices</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="pcl_2typedefs__fwd_8h_source.html#l00046">46</a> of file <a class="el" href="pcl_2typedefs__fwd_8h_source.html">pcl/typedefs_fwd.h</a>.</p>

</div>
</div>
<a class="anchor" id="a67b382c4f27765dbb10e85e47ca27d04"></a><!-- doxytag: member="elm::VtxColor" ref="a67b382c4f27765dbb10e85e47ca27d04" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef int <a class="el" href="namespaceelm.html#a67b382c4f27765dbb10e85e47ca27d04">elm::VtxColor</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="graphattr__impl__typedefs_8h_source.html#l00025">25</a> of file <a class="el" href="graphattr__impl__typedefs_8h_source.html">graphattr_impl_typedefs.h</a>.</p>

</div>
</div>
<a class="anchor" id="ad982cfe915f0437c796294b5f5cfe50a"></a><!-- doxytag: member="elm::VtxDescriptor" ref="ad982cfe915f0437c796294b5f5cfe50a" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef GraphAttrTraits::vertex_descriptor <a class="el" href="namespaceelm.html#ad982cfe915f0437c796294b5f5cfe50a">elm::VtxDescriptor</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="graphattr__impl__typedefs_8h_source.html#l00035">35</a> of file <a class="el" href="graphattr__impl__typedefs_8h_source.html">graphattr_impl_typedefs.h</a>.</p>

</div>
</div>
<a class="anchor" id="a0fe056d1afa48fefa80d496294a43c01"></a><!-- doxytag: member="elm::VtxIdx2" ref="a0fe056d1afa48fefa80d496294a43c01" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="namespacecv.html#a9747ac59f97cbb93ddd719c4fb3e2d5d">cv::Mat1f</a> <a class="el" href="namespaceelm.html#a0fe056d1afa48fefa80d496294a43c01">elm::VtxIdx2</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="graphattr__impl__typedefs_8h_source.html#l00026">26</a> of file <a class="el" href="graphattr__impl__typedefs_8h_source.html">graphattr_impl_typedefs.h</a>.</p>

</div>
</div>
<a class="anchor" id="a2396f62943ed002804ccf6b846e41e5c"></a><!-- doxytag: member="elm::VtxProp" ref="a2396f62943ed002804ccf6b846e41e5c" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef boost::property&lt;boost::vertex_color_t, <a class="el" href="namespaceelm.html#a67b382c4f27765dbb10e85e47ca27d04">VtxColor</a>, boost::property&lt;boost::vertex_index2_t, <a class="el" href="namespaceelm.html#a0fe056d1afa48fefa80d496294a43c01">VtxIdx2</a> &gt; &gt; <a class="el" href="namespaceelm.html#a2396f62943ed002804ccf6b846e41e5c">elm::VtxProp</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="graphattr__impl__typedefs_8h_source.html#l00029">29</a> of file <a class="el" href="graphattr__impl__typedefs_8h_source.html">graphattr_impl_typedefs.h</a>.</p>

</div>
</div>
<hr/><h2>Enumeration Type Documentation</h2>
<a class="anchor" id="ac5c73e977e493677f8bddc01b875db02"></a><!-- doxytag: member="elm::LayerIOKeyType" ref="ac5c73e977e493677f8bddc01b875db02" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespaceelm.html#ac5c73e977e493677f8bddc01b875db02">elm::LayerIOKeyType</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl><dt><b>Enumerator: </b></dt><dd><table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em><a class="anchor" id="ac5c73e977e493677f8bddc01b875db02a545de7206d5b4db861ab95949110fa41"></a><!-- doxytag: member="INPUT" ref="ac5c73e977e493677f8bddc01b875db02a545de7206d5b4db861ab95949110fa41" args="" -->INPUT</em>&nbsp;</td><td>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="ac5c73e977e493677f8bddc01b875db02a4ec4df54fa48cebdafa34d152f2ab55f"></a><!-- doxytag: member="OUTPUT" ref="ac5c73e977e493677f8bddc01b875db02a4ec4df54fa48cebdafa34d152f2ab55f" args="" -->OUTPUT</em>&nbsp;</td><td>
</td></tr>
</table>
</dd>
</dl>

<p>Definition at line <a class="el" href="layerattr___8h_source.html#l00016">16</a> of file <a class="el" href="layerattr___8h_source.html">layerattr_.h</a>.</p>

</div>
</div>
<hr/><h2>Function Documentation</h2>
<a class="anchor" id="aba4d101c9dee988ae21a72c9b79ce2c4"></a><!-- doxytag: member="elm::ARange_" ref="aba4d101c9dee988ae21a72c9b79ce2c4" args="(T start, T stop, T step)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">cv::Mat_&lt;T&gt; <a class="el" href="namespaceelm.html#aba4d101c9dee988ae21a72c9b79ce2c4">elm::ARange_</a> </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>stop</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>step</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Create Mat object (row vector) and fill with range. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">start</td><td>value </td></tr>
    <tr><td class="paramname">stop</td><td>value (exclusive) </td></tr>
    <tr><td class="paramname">step</td><td>value </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>template </dd></dl>

<p>Definition at line <a class="el" href="mat__utils__inl_8h_source.html#l00067">67</a> of file <a class="el" href="mat__utils__inl_8h_source.html">mat_utils_inl.h</a>.</p>

</div>
</div>
<a class="anchor" id="a4c9565cace7f9e79b2884fb1a0b8f7f8"></a><!-- doxytag: member="elm::CondEntropy" ref="a4c9565cace7f9e79b2884fb1a0b8f7f8" args="(cv::InputArray pdf)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">float <a class="el" href="namespaceelm.html#a4c9565cace7f9e79b2884fb1a0b8f7f8">elm::CondEntropy</a> </td>
          <td>(</td>
          <td class="paramtype">cv::InputArray&#160;</td>
          <td class="paramname"><em>pdf</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Compute the normalized conditional entropy of a probability distribution. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">pdf</td><td>as matrix of vector of floats </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>normalized cond. entropy. Returns 0 on empty input. </dd></dl>

</div>
</div>
<a class="anchor" id="a6e92e65b4ec4111e3ee01dfc1a3ded03"></a><!-- doxytag: member="elm::ConvertTo8U" ref="a6e92e65b4ec4111e3ee01dfc1a3ded03" args="(const cv::Mat &amp;src)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">cv::Mat_&lt;unsigned char&gt; <a class="el" href="namespaceelm.html#a6e92e65b4ec4111e3ee01dfc1a3ded03">elm::ConvertTo8U</a> </td>
          <td>(</td>
          <td class="paramtype">const cv::Mat &amp;&#160;</td>
          <td class="paramname"><em>src</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Converts matrix to 8U and scales elements so that min=0 and max=255. </p>
<p>If all input elements are identical, yield matrix of zeros</p>
<p>Useful for preparing matrix to use with highgui's cv::imshow()</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">src</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Mat_&lt;uchar&gt; </dd></dl>

</div>
</div>
<a class="anchor" id="ab8475df4365d79afa3006ccdc7cd0c52"></a><!-- doxytag: member="elm::CumSum" ref="ab8475df4365d79afa3006ccdc7cd0c52" args="(const cv::Mat1f &amp;src, cv::Mat1f &amp;dst)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="namespaceelm.html#ab8475df4365d79afa3006ccdc7cd0c52">elm::CumSum</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacecv.html#a9747ac59f97cbb93ddd719c4fb3e2d5d">cv::Mat1f</a> &amp;&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacecv.html#a9747ac59f97cbb93ddd719c4fb3e2d5d">cv::Mat1f</a> &amp;&#160;</td>
          <td class="paramname"><em>dst</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Cumulative sum. </p>
<p>Input of zeros yields cumulative sum of zeros</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">src</td><td>matrix </td></tr>
    <tr><td class="paramname">dst</td><td>matrix </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="af074d4ceef14f0102ce06b4367a732d2"></a><!-- doxytag: member="elm::diff" ref="af074d4ceef14f0102ce06b4367a732d2" args="(const cv::Mat1f &amp;src, int n=1, int axis=&#45;1)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacecv.html#a9747ac59f97cbb93ddd719c4fb3e2d5d">cv::Mat1f</a> <a class="el" href="namespaceelm.html#af074d4ceef14f0102ce06b4367a732d2">elm::diff</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacecv.html#a9747ac59f97cbb93ddd719c4fb3e2d5d">cv::Mat1f</a> &amp;&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em> = <code>1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>axis</em> = <code>-1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>n-th order discrete forward diff along an axis. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">src</td><td>Mat </td></tr>
    <tr><td class="paramname">n</td><td>no. of times values are differenced </td></tr>
    <tr><td class="paramname">axis</td><td>along which to perform forward difference (default is the last axis) </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>resulting difference </dd></dl>

</div>
</div>
<a class="anchor" id="a6212361bc80c580bc6061d1a583a8611"></a><!-- doxytag: member="elm::ElementsAt" ref="a6212361bc80c580bc6061d1a583a8611" args="(const VecMat1f &amp;v, int row, int col)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacecv.html#a9747ac59f97cbb93ddd719c4fb3e2d5d">cv::Mat1f</a> <a class="el" href="namespaceelm.html#a6212361bc80c580bc6061d1a583a8611">elm::ElementsAt</a> </td>
          <td>(</td>
          <td class="paramtype">const VecMat1f &amp;&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>row</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>col</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get all element values at a position across different matrices. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">vector</td><td>of matrices </td></tr>
    <tr><td class="paramname">row</td><td></td></tr>
    <tr><td class="paramname">col</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>row matrix with extracted elements </dd></dl>
<dl class="exception"><dt><b>Exceptions:</b></dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classelm_1_1ExceptionBadDims.html">ExceptionBadDims</a></td><td>for positions that cannot be accessed. </td></tr>
  </table>
  </dd>
</dl>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000002">Todo:</a></b></dt><dd>validate equally sized matrices inside vector or define protocol current behavior, rely on dims of first vector entry </dd></dl>

</div>
</div>
<a class="anchor" id="ade130b3139af2a820c2215b6a8eafbfc"></a><!-- doxytag: member="elm::Find" ref="ade130b3139af2a820c2215b6a8eafbfc" args="(const std::map&lt; std::string, T &gt; &amp;map, const std::string &amp;key, T &amp;obj)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="namespaceelm.html#ade130b3139af2a820c2215b6a8eafbfc">elm::Find</a> </td>
          <td>(</td>
          <td class="paramtype">const std::map&lt; std::string, T &gt; &amp;&#160;</td>
          <td class="paramname"><em>map</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>obj</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Find key in map and provide corresponding object if exists. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">map</td><td>to search </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">key</td><td>to search for </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">object</td><td>if exists </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>true if found </dd></dl>

<p>Definition at line <a class="el" href="modules_2elm_2core_2stl_2stl__inl_8h_source.html#l00036">36</a> of file <a class="el" href="modules_2elm_2core_2stl_2stl__inl_8h_source.html">modules/elm/core/stl/stl_inl.h</a>.</p>

</div>
</div>
<a class="anchor" id="aeebe2356ec3446a39abcaf5d09f731eb"></a><!-- doxytag: member="elm::find_first_of" ref="aeebe2356ec3446a39abcaf5d09f731eb" args="(const cv::Mat &amp;m, const T &amp;value, int &amp;index=elm::NA_IDX)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="namespaceelm.html#aeebe2356ec3446a39abcaf5d09f731eb">elm::find_first_of</a> </td>
          <td>(</td>
          <td class="paramtype">const cv::Mat &amp;&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int &amp;&#160;</td>
          <td class="paramname"><em>index</em> = <code><a class="el" href="namespaceelm.html#a7713a3d419c89693eab7bf0f82f4540e">elm::NA_IDX</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>get first index of element with a specific value in matrix Inspired by this Stack Overflow post: </p>
<dl class="see"><dt><b>See also:</b></dt><dd><a href="http://stackoverflow.com/questions/25835587/find-element-in-opencv-mat-efficiently">http://stackoverflow.com/questions/25835587/find-element-in-opencv-mat-efficiently</a></dd></dl>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">matrix</td><td>to search in </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">value</td><td>to search for </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">first</td><td>index containing this value, only meaningful if found </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>true if sucessfully found, always flase for empty input.</dd></dl>
<dl class="exception"><dt><b>Exceptions:</b></dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classelm_1_1ExceptionBadDims.html">ExceptionBadDims</a></td><td>if no. of channels != 1, <a class="el" href="classelm_1_1ExceptionTypeError.html">ExceptionTypeError</a> for non-continuous matrix input. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="mat__utils__inl_8h_source.html#l00036">36</a> of file <a class="el" href="mat__utils__inl_8h_source.html">mat_utils_inl.h</a>.</p>

</div>
</div>
<a class="anchor" id="a86b2edbd0f0d421ddbd35d79d242a439"></a><!-- doxytag: member="elm::FullTestName" ref="a86b2edbd0f0d421ddbd35d79d242a439" args="(const ::testing::TestInfo *test_info)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char* <a class="el" href="namespaceelm.html#a86b2edbd0f0d421ddbd35d79d242a439">elm::FullTestName</a> </td>
          <td>(</td>
          <td class="paramtype">const ::testing::TestInfo *&#160;</td>
          <td class="paramname"><em>test_info</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="ab1cadb05efc348b5b0e59c39d744c0ff"></a><!-- doxytag: member="elm::GetVersion" ref="ab1cadb05efc348b5b0e59c39d744c0ff" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char* <a class="el" href="namespaceelm.html#ab1cadb05efc348b5b0e59c39d744c0ff">elm::GetVersion</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a5bd71c1c7a75aa859e6993988e5ab3b9"></a><!-- doxytag: member="elm::InitializeIONames" ref="a5bd71c1c7a75aa859e6993988e5ab3b9" args="(const MapIONames &amp;io_pairs, const VecS &amp;keys, LayerIONames &amp;dst)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="namespaceelm.html#a5bd71c1c7a75aa859e6993988e5ab3b9">elm::InitializeIONames</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceelm.html#a2b8eb7cd84832a6a64c0da7dad94304a">MapIONames</a> &amp;&#160;</td>
          <td class="paramname"><em>io_pairs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceelm.html#acebbd34f9c41c07c407aca3a77311412">VecS</a> &amp;&#160;</td>
          <td class="paramname"><em>keys</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classelm_1_1LayerIONames.html">LayerIONames</a> &amp;&#160;</td>
          <td class="paramname"><em>dst</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Facotry function for initializing io names from a subset of io pairs. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">io_pairs</td><td></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">keys</td><td>I/O keys to use in initialization </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">dst</td><td>resulting object </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ae731b95db17713365266f645d4ff293c"></a><!-- doxytag: member="elm::is_not_nan" ref="ae731b95db17713365266f645d4ff293c" args="(const cv::Mat1f &amp;src)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacecv.html#ac705c6d749e0795c44314245643a55e0">cv::Mat1b</a> <a class="el" href="namespaceelm.html#ae731b95db17713365266f645d4ff293c">elm::is_not_nan</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacecv.html#a9747ac59f97cbb93ddd719c4fb3e2d5d">cv::Mat1f</a> &amp;&#160;</td>
          <td class="paramname"><em>src</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>get mask of elements that are valid numbers (not NaN) in a matrix </p>
<p>NaN as defined by IEEE754 standard</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">src</td><td>matrix </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>mask of non-nan elements (true where element != NaN) </dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd>is_nan() </dd></dl>

</div>
</div>
<a class="anchor" id="a0086a6b2300114456b353753537a8ea1"></a><!-- doxytag: member="elm::isnan" ref="a0086a6b2300114456b353753537a8ea1" args="(const cv::Mat1f &amp;src)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacecv.html#ac705c6d749e0795c44314245643a55e0">cv::Mat1b</a> <a class="el" href="namespaceelm.html#a0086a6b2300114456b353753537a8ea1">elm::isnan</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacecv.html#a9747ac59f97cbb93ddd719c4fb3e2d5d">cv::Mat1f</a> &amp;&#160;</td>
          <td class="paramname"><em>src</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>get mask of nan elements in a matrix </p>
<p>NaN as defined by IEEE754 standard</p>
<p><a href="http://answers.opencv.org/question/2221/create-a-mask-for-nan-cells/">http://answers.opencv.org/question/2221/create-a-mask-for-nan-cells/</a> Restricted to Mat of floats for which the standard provides a NaN definition. <a href="http://stackoverflow.com/questions/3949457/can-an-integer-be-nan-in-c">http://stackoverflow.com/questions/3949457/can-an-integer-be-nan-in-c</a></p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">src</td><td>matrix of floats </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>mask of nan elements (true where element == NaN) </dd></dl>

</div>
</div>
<a class="anchor" id="a639456db50fb0568bf034200fee2c8e4"></a><!-- doxytag: member="elm::Keys" ref="a639456db50fb0568bf034200fee2c8e4" args="(const std::map&lt; TKey, TVal &gt; &amp;m)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TKey , class TVal &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;TKey &gt; <a class="el" href="namespaceelm.html#a639456db50fb0568bf034200fee2c8e4">elm::Keys</a> </td>
          <td>(</td>
          <td class="paramtype">const std::map&lt; TKey, TVal &gt; &amp;&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>List all keys in a map. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">map</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>vector of all map keys </dd></dl>

<p>Definition at line <a class="el" href="modules_2elm_2core_2stl_2stl__inl_8h_source.html#l00053">53</a> of file <a class="el" href="modules_2elm_2core_2stl_2stl__inl_8h_source.html">modules/elm/core/stl/stl_inl.h</a>.</p>

</div>
</div>
<a class="anchor" id="a201610be6b9b06901bb3ae0d5da92e1d"></a><!-- doxytag: member="elm::LayerGraph::Reconfigure&lt; std::string &gt;" ref="a201610be6b9b06901bb3ae0d5da92e1d" args="(const std::string &amp;key, const std::string &amp;value)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classelm_1_1LayerGraph.html#ac942e4d6b4aada37ea61080a2272b712">elm::LayerGraph::Reconfigure</a>&lt; std::string &gt; </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a7d050b2cbd04b01dab74e43818485b40"></a><!-- doxytag: member="elm::Load" ref="a7d050b2cbd04b01dab74e43818485b40" args="(Tarchive &amp;ar, cv::Mat_&lt; TElem &gt; &amp;obj)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Tarchive , class TElem &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="namespaceelm.html#a7d050b2cbd04b01dab74e43818485b40">elm::Load</a> </td>
          <td>(</td>
          <td class="paramtype">Tarchive &amp;&#160;</td>
          <td class="paramname"><em>ar</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">cv::Mat_&lt; TElem &gt; &amp;&#160;</td>
          <td class="paramname"><em>obj</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="ser__mat__utils_8h_source.html#l00023">23</a> of file <a class="el" href="ser__mat__utils_8h_source.html">ser_mat_utils.h</a>.</p>

</div>
</div>
<a class="anchor" id="a4261bafcd535e25627304fa2c8528075"></a><!-- doxytag: member="elm::Load" ref="a4261bafcd535e25627304fa2c8528075" args="(const boost::filesystem::path &amp;p, T &amp;obj)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="namespaceelm.html#a7d050b2cbd04b01dab74e43818485b40">elm::Load</a> </td>
          <td>(</td>
          <td class="paramtype">const boost::filesystem::path &amp;&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>obj</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="file__serialization_8h_source.html#l00090">90</a> of file <a class="el" href="file__serialization_8h_source.html">file_serialization.h</a>.</p>

</div>
</div>
<a class="anchor" id="ae16129661373468d07f6a87c7600de66"></a><!-- doxytag: member="elm::MapSSToPTree" ref="ae16129661373468d07f6a87c7600de66" args="(const MapSS &amp;src, PTree &amp;dst)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="namespaceelm.html#ae16129661373468d07f6a87c7600de66">elm::MapSSToPTree</a> </td>
          <td>(</td>
          <td class="paramtype">const MapSS &amp;&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PTree &amp;&#160;</td>
          <td class="paramname"><em>dst</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Convert map to property tree. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">src</td><td>map </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">dst</td><td>property tree </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a61419ccc8ba498196ec3257f172acd7c"></a><!-- doxytag: member="elm::Mat2Point2i" ref="a61419ccc8ba498196ec3257f172acd7c" args="(const cv::Mat1i &amp;m)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacecv.html#a0f70b52f0c0b119f7ed2448ffebdc144">cv::Point2i</a> <a class="el" href="namespaceelm.html#a61419ccc8ba498196ec3257f172acd7c">elm::Mat2Point2i</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacecv.html#a87332e283de569e7bb029d4f4b401dcc">cv::Mat1i</a> &amp;&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Convert matrix of integers into a 2-dimensional point. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">matrix</td><td>(only first two elements will be considered) </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>point of matrix' first 2 elements </dd></dl>
<dl class="exception"><dt><b>Exceptions:</b></dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classelm_1_1ExceptionBadDims.html">elm::ExceptionBadDims</a></td><td>if matrix contains less than 2 elements </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a07d6cae24a269481639b6dc7677c7ba1"></a><!-- doxytag: member="elm::Mat2Point3_" ref="a07d6cae24a269481639b6dc7677c7ba1" args="(const cv::Mat_&lt; T &gt; &amp;m)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">cv::Point3_&lt;T&gt; <a class="el" href="namespaceelm.html#a07d6cae24a269481639b6dc7677c7ba1">elm::Mat2Point3_</a> </td>
          <td>(</td>
          <td class="paramtype">const cv::Mat_&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Convert matrix of T (int or float) into a 3-dimensional point. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">matrix</td><td>(only first 3 elements will be considered) </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>point of matrix' first 3 elements </dd></dl>
<dl class="exception"><dt><b>Exceptions:</b></dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classelm_1_1ExceptionBadDims.html">elm::ExceptionBadDims</a></td><td>if matrix contains less than 3 elements </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a51484199ba2c17f38e34678f33821e62"></a><!-- doxytag: member="elm::Mat2PointCloud_" ref="a51484199ba2c17f38e34678f33821e62" args="(const cv::Mat1f &amp;m)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TPoint &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">boost::shared_ptr&lt;pcl::PointCloud&lt;TPoint &gt; &gt; <a class="el" href="namespaceelm.html#a51484199ba2c17f38e34678f33821e62">elm::Mat2PointCloud_</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacecv.html#a9747ac59f97cbb93ddd719c4fb3e2d5d">cv::Mat1f</a> &amp;&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Convert a single-channel Mat of floats to point cloud. </p>
<p>Involves a deep copy of matrix elements</p>
<p>Types for which specializations exist: pcl::PointXYZ, pcl::Normal, pcl::PointNormal</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">source</td><td>matrix </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>pointer to point cloud instance</dd></dl>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000009">Todo:</a></b></dt><dd><p class="startdd">Avoid deep copy </p>
<p class="enddd">produce clearer error messages for types without specializations </p>
</dd></dl>

</div>
</div>
<a class="anchor" id="a45180339ab7fe4e54b975a589b590424"></a><!-- doxytag: member="elm::Mat2VecVertices" ref="a45180339ab7fe4e54b975a589b590424" args="(const cv::Mat &amp;m)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceelm.html#a920280bb0e893412086bdea6aa980e9d">VecVertices</a> <a class="el" href="namespaceelm.html#a45180339ab7fe4e54b975a589b590424">elm::Mat2VecVertices</a> </td>
          <td>(</td>
          <td class="paramtype">const cv::Mat &amp;&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Convert Mat of floats to vector of pcl Vertices. </p>
<p>Unfortunately, a shallow copy did not work, this will be a deep copy.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">Mat</td><td>with vertices info </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>vector of verrtices</dd></dl>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000013">Todo:</a></b></dt><dd>We know how to convert a Mat_&lt;T1&gt; -&gt; STL vector&lt;T1&gt; but for this we need to convert a Mat_&lt;T1&gt; -&gt; STL vector&lt;T2!&gt; </dd></dl>

</div>
</div>
<a class="anchor" id="a83700a389d44a79354197cd9e7db179a"></a><!-- doxytag: member="elm::Mat_ToVec_" ref="a83700a389d44a79354197cd9e7db179a" args="(const cv::Mat_&lt; T &gt; &amp;m)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;T&gt; <a class="el" href="namespaceelm.html#a83700a389d44a79354197cd9e7db179a">elm::Mat_ToVec_</a> </td>
          <td>(</td>
          <td class="paramtype">const cv::Mat_&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Function for converting a Mat_ object into a vector of same type The mat is flattened beforehand. </p>
<p>Involves copying elements May only work with matrices of POD (e.g. int, float, uchar,...) Works with N-dimensional matrices</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">matrix</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>resulting vector with flattened matrix data </dd></dl>
<dl class="exception"><dt><b>Exceptions:</b></dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classelm_1_1ExceptionTypeError.html">ExceptionTypeError</a></td><td>on non-continuous matrix input </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="mat__vector__utils__inl_8h_source.html#l00037">37</a> of file <a class="el" href="mat__vector__utils__inl_8h_source.html">mat_vector_utils_inl.h</a>.</p>

</div>
</div>
<a class="anchor" id="ae0e1b7aaab323d6e21a2bda8d38468fe"></a><!-- doxytag: member="elm::MatToRect2i" ref="ae0e1b7aaab323d6e21a2bda8d38468fe" args="(const cv::Mat1i &amp;m)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacecv.html#aa87c8f580952d28b4127261994bce7d8">cv::Rect2i</a> <a class="el" href="namespaceelm.html#ae0e1b7aaab323d6e21a2bda8d38468fe">elm::MatToRect2i</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacecv.html#a87332e283de569e7bb029d4f4b401dcc">cv::Mat1i</a> &amp;&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Convert row Matrix of ints to Rect object. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">Row</td><td>matrix with rectangle data [tl.x, tl.y, br.x, br.y] </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Rectangle </dd></dl>
<dl class="exception"><dt><b>Exceptions:</b></dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classelm_1_1ExceptionBadDims.html">elm::ExceptionBadDims</a></td><td>on input Mat with less than 4 elements </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ad6facf27172e5a0d2db13d34cf4ab27f"></a><!-- doxytag: member="elm::MatTypeToString" ref="ad6facf27172e5a0d2db13d34cf4ab27f" args="(const cv::Mat &amp;m)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string <a class="el" href="namespaceelm.html#ad6facf27172e5a0d2db13d34cf4ab27f">elm::MatTypeToString</a> </td>
          <td>(</td>
          <td class="paramtype">const cv::Mat &amp;&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get string representation of matrix type. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">matrix</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>type as string </dd></dl>

</div>
</div>
<a class="anchor" id="a189306ef4c8548b1f99b39fc445a0c7c"></a><!-- doxytag: member="elm::NeighMeanVar" ref="a189306ef4c8548b1f99b39fc445a0c7c" args="(const cv::Mat1f &amp;m, int radius, cv::Mat1f &amp;neigh_mean, cv::Mat1f &amp;neigh_var, int border_type=cv::BORDER_REPLICATE, const cv::Scalar &amp;value=cv::Scalar())" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="namespaceelm.html#a189306ef4c8548b1f99b39fc445a0c7c">elm::NeighMeanVar</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacecv.html#a9747ac59f97cbb93ddd719c4fb3e2d5d">cv::Mat1f</a> &amp;&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>radius</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacecv.html#a9747ac59f97cbb93ddd719c4fb3e2d5d">cv::Mat1f</a> &amp;&#160;</td>
          <td class="paramname"><em>neigh_mean</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacecv.html#a9747ac59f97cbb93ddd719c4fb3e2d5d">cv::Mat1f</a> &amp;&#160;</td>
          <td class="paramname"><em>neigh_var</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>border_type</em> = <code>cv::BORDER_REPLICATE</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const cv::Scalar &amp;&#160;</td>
          <td class="paramname"><em>value</em> = <code>cv::Scalar()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Calculate neighborhood variance. </p>
<p>Border elements are zero-padded </p>
<dl class="see"><dt><b>See also:</b></dt><dd><a href="http://docs.opencv.org/doc/tutorials/imgproc/imgtrans/copyMakeBorder/copyMakeBorder.html">http://docs.opencv.org/doc/tutorials/imgproc/imgtrans/copyMakeBorder/copyMakeBorder.html</a></dd></dl>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">source</td><td>matrix </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">neighborhood</td><td>radius </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">matrix</td><td>with neighborhood mean around each element </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">matrix</td><td>with neighborhood variance around each element </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">border</td><td>type - </td></tr>
  </table>
  </dd>
</dl>
<dl class="see"><dt><b>See also:</b></dt><dd>OpenCV's copyMakeBorder() or borderInterpolate() for details. default is cv::BORDER_REPLICATE </dd></dl>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">value</td><td>- Border value if border type==BORDER_CONSTANT </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a9ea7cc03476209de8d7d832a111c7cfd"></a><!-- doxytag: member="elm::operator&lt;&lt;" ref="a9ea7cc03476209de8d7d832a111c7cfd" args="(std::ostream &amp;os, FeatureData &amp;obj)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; elm::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FeatureData &amp;&#160;</td>
          <td class="paramname"><em>obj</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a280dcde77b49b89660aea127c42ea9a8"></a><!-- doxytag: member="elm::Point2Mat" ref="a280dcde77b49b89660aea127c42ea9a8" args="(const cv::Point2i &amp;p)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacecv.html#a87332e283de569e7bb029d4f4b401dcc">cv::Mat1i</a> <a class="el" href="namespaceelm.html#a280dcde77b49b89660aea127c42ea9a8">elm::Point2Mat</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacecv.html#a0f70b52f0c0b119f7ed2448ffebdc144">cv::Point2i</a> &amp;&#160;</td>
          <td class="paramname"><em>p</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Convert 2d point of integers to single channel Mat of integers. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">2d</td><td>point of integers </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>single channel row-matrix of integers [x, y] </dd></dl>

</div>
</div>
<a class="anchor" id="a3bb5480fb3881faf63af4a429a8d0a4c"></a><!-- doxytag: member="elm::PointCloud2Mat_" ref="a3bb5480fb3881faf63af4a429a8d0a4c" args="(boost::shared_ptr&lt; pcl::PointCloud&lt; TPoint &gt; &gt; &amp;cloud_ptr)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TPoint &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacecv.html#a9747ac59f97cbb93ddd719c4fb3e2d5d">cv::Mat1f</a> <a class="el" href="namespaceelm.html#a3bb5480fb3881faf63af4a429a8d0a4c">elm::PointCloud2Mat_</a> </td>
          <td>(</td>
          <td class="paramtype">boost::shared_ptr&lt; pcl::PointCloud&lt; TPoint &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>cloud_ptr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Convert point cloud to OpenCV's single-channel Mat of floats. </p>
<p>No deep copy involved, ownership of underlying data remains with point cloud. CAUTION: output Mat data becomes invalid if source cloud goes out of scope.</p>
<p>Types for which specializations exist: pcl::PointXYZ, pcl::Normal, pcl::PointNormal</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">source</td><td>point cloud </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>resulting Mat </dd></dl>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000010">Todo:</a></b></dt><dd>produce clearer error messages for types without specializations </dd></dl>

</div>
</div>
<a class="anchor" id="add31de4aaf91a19fc02789189c47764e"></a><!-- doxytag: member="elm::PrintXML" ref="add31de4aaf91a19fc02789189c47764e" args="(const PTree &amp;pt, std::basic_ostream&lt; typename PTree::key_type::value_type &gt; &amp;stream)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="namespaceelm.html#add31de4aaf91a19fc02789189c47764e">elm::PrintXML</a> </td>
          <td>(</td>
          <td class="paramtype">const PTree &amp;&#160;</td>
          <td class="paramname"><em>pt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::basic_ostream&lt; typename PTree::key_type::value_type &gt; &amp;&#160;</td>
          <td class="paramname"><em>stream</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Print a ptree to standard out in xml format. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">property</td><td>tree to print </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">output</td><td>stream, (e.g std::cout) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a6f5ac7f4d3c51fc096c16ccc1023faa5"></a><!-- doxytag: member="elm::PTreeToMapSS" ref="a6f5ac7f4d3c51fc096c16ccc1023faa5" args="(const PTree &amp;src, MapSS &amp;dst)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="namespaceelm.html#a6f5ac7f4d3c51fc096c16ccc1023faa5">elm::PTreeToMapSS</a> </td>
          <td>(</td>
          <td class="paramtype">const PTree &amp;&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MapSS &amp;&#160;</td>
          <td class="paramname"><em>dst</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Convert property tree to map. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">src</td><td>source property tree </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">dst</td><td>map </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a94639d3e188e5de0c37d47a620324c56"></a><!-- doxytag: member="elm::push_back_child" ref="a94639d3e188e5de0c37d47a620324c56" args="(const PTree &amp;p, const std::string &amp;key, std::vector&lt; T &gt; &amp;v)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="namespaceelm.html#a94639d3e188e5de0c37d47a620324c56">elm::push_back_child</a> </td>
          <td>(</td>
          <td class="paramtype">const PTree &amp;&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>push back elements from property_tree into a vector </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">source</td><td>tree </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">node</td><td>key </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">vector</td><td>to push elements into </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt><b>Exceptions:</b></dt><dd>
  <table class="exception">
    <tr><td class="paramname">boost::property_tree::ptree_bad_path</td><td>for keys that do not exist </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="ptree__utils__inl_8h_source.html#l00042">42</a> of file <a class="el" href="ptree__utils__inl_8h_source.html">ptree_utils_inl.h</a>.</p>

</div>
</div>
<a class="anchor" id="a0e9eb99fe59b32ea73813ffac64ad47b"></a><!-- doxytag: member="elm::push_back_randu" ref="a0e9eb99fe59b32ea73813ffac64ad47b" args="(std::vector&lt; T &gt; &amp;v, int N)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="namespaceelm.html#a0e9eb99fe59b32ea73813ffac64ad47b">elm::push_back_randu</a> </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>N</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Push back uniformly random values into a vector. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">vector</td><td>pushing back into </td></tr>
    <tr><td class="paramname">no.</td><td>of items to push back </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="modules_2elm_2core_2stl_2stl__inl_8h_source.html#l00091">91</a> of file <a class="el" href="modules_2elm_2core_2stl_2stl__inl_8h_source.html">modules/elm/core/stl/stl_inl.h</a>.</p>

</div>
</div>
<a class="anchor" id="a8824e803fe2c2743750c37e4216f6cff"></a><!-- doxytag: member="elm::randexp" ref="a8824e803fe2c2743750c37e4216f6cff" args="(float lambda)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">float <a class="el" href="namespaceelm.html#a8824e803fe2c2743750c37e4216f6cff">elm::randexp</a> </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>lambda</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Draw sample from exponential distribution. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">lambda</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>sample drawn from exponential distribution </dd></dl>

</div>
</div>
<a class="anchor" id="a05b0b20e2cc38b8881a5610ea56eaade"></a><!-- doxytag: member="elm::Rect2iToMat" ref="a05b0b20e2cc38b8881a5610ea56eaade" args="(const cv::Rect2i &amp;r)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacecv.html#a87332e283de569e7bb029d4f4b401dcc">cv::Mat1i</a> <a class="el" href="namespaceelm.html#a05b0b20e2cc38b8881a5610ea56eaade">elm::Rect2iToMat</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacecv.html#aa87c8f580952d28b4127261994bce7d8">cv::Rect2i</a> &amp;&#160;</td>
          <td class="paramname"><em>r</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Convert Rect of ints to a row Matrix of ints. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">r</td><td>Rectangle </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Row matrix with rectangle data [tl.x, tl.y, br.x, br.y] </dd></dl>

</div>
</div>
<a class="anchor" id="a05c2f8d7413febd82d4d3b0084bab782"></a><!-- doxytag: member="elm::REGISTER_TYPED_TEST_CASE_P" ref="a05c2f8d7413febd82d4d3b0084bab782" args="(LearningLayer_TP_, Clear, Constructor, Destructor)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceelm.html#a1a6d6179436fe5c4bc9b95a77f881afa">elm::REGISTER_TYPED_TEST_CASE_P</a> </td>
          <td>(</td>
          <td class="paramtype">LearningLayer_TP_&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Clear&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Constructor&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Destructor&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>register additional typed_test_p (i.e. unit test) routines here </p>

</div>
</div>
<a class="anchor" id="acb5d5e63b71842548f0ee4894b42cd90"></a><!-- doxytag: member="elm::REGISTER_TYPED_TEST_CASE_P" ref="acb5d5e63b71842548f0ee4894b42cd90" args="(LayerFeatTransf_TP_, Response_exists)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceelm.html#a1a6d6179436fe5c4bc9b95a77f881afa">elm::REGISTER_TYPED_TEST_CASE_P</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classelm_1_1LayerFeatTransf__TP__.html">LayerFeatTransf_TP_</a>&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Response_exists&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>register additional typed_test_p (i.e. unit test) routines here </p>

</div>
</div>
<a class="anchor" id="a1a6d6179436fe5c4bc9b95a77f881afa"></a><!-- doxytag: member="elm::REGISTER_TYPED_TEST_CASE_P" ref="a1a6d6179436fe5c4bc9b95a77f881afa" args="(Layer_TP_, Clear, Constructor, Destructor, RequiredIONamesValidation)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceelm.html#a1a6d6179436fe5c4bc9b95a77f881afa">elm::REGISTER_TYPED_TEST_CASE_P</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classelm_1_1Layer__TP__.html">Layer_TP_</a>&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Clear&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Constructor&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Destructor&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">RequiredIONamesValidation&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>register additional typed_test_p (i.e. unit test) routines here </p>

</div>
</div>
<a class="anchor" id="a98a416c3b2ed4e0bc00a83bebf67c283"></a><!-- doxytag: member="elm::REGISTER_TYPED_TEST_CASE_P" ref="a98a416c3b2ed4e0bc00a83bebf67c283" args="(LayerInst_TP_, Clear, Constructor, Destructor)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceelm.html#a1a6d6179436fe5c4bc9b95a77f881afa">elm::REGISTER_TYPED_TEST_CASE_P</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classelm_1_1LayerInst__TP__.html">LayerInst_TP_</a>&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Clear&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Constructor&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Destructor&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>register additional typed_test_p (i.e. unit test) routines here </p>

</div>
</div>
<a class="anchor" id="aeb4692dee32b0177db74beb68014ed2e"></a><!-- doxytag: member="elm::REGISTER_TYPED_TEST_CASE_P" ref="aeb4692dee32b0177db74beb68014ed2e" args="(Signal_TP_, Constructor, Clear, FeatureNames, GetFeatures, MostRecent_Invalid, Append, MostRecent_after_Append)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceelm.html#a1a6d6179436fe5c4bc9b95a77f881afa">elm::REGISTER_TYPED_TEST_CASE_P</a> </td>
          <td>(</td>
          <td class="paramtype">Signal_TP_&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Constructor&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Clear&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FeatureNames&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">GetFeatures&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MostRecent_Invalid&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Append&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MostRecent_after_Append&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>register additional typed_test_p (i.e. unit test) routines here </p>

</div>
</div>
<a class="anchor" id="ae5d005a6fd90d7a2b95e75c0cb5f651e"></a><!-- doxytag: member="elm::Reshape" ref="ae5d005a6fd90d7a2b95e75c0cb5f651e" args="(const VecMat1f &amp;v)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacecv.html#a9747ac59f97cbb93ddd719c4fb3e2d5d">cv::Mat1f</a> <a class="el" href="namespaceelm.html#ae5d005a6fd90d7a2b95e75c0cb5f651e">elm::Reshape</a> </td>
          <td>(</td>
          <td class="paramtype">const VecMat1f &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Reshape vector of mat to single mat with row per element and col per vector element/block/kernel. </p>
<p>Only applicable to vector of equally sized matrices. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">input</td><td>vector of matrices </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>single matrix, row per matrix element and cols=vector size, all dims are non-zero </dd></dl>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000003">Todo:</a></b></dt><dd>enforce validation of same-dim matrix elements or define clear protocol, current behavior: rely on dims of first vector entry </dd></dl>

</div>
</div>
<a class="anchor" id="ac20352760a019c40a2b3559fed186341"></a><!-- doxytag: member="elm::Save" ref="ac20352760a019c40a2b3559fed186341" args="(Tarchive &amp;ar, const cv::Mat_&lt; TElem &gt; &amp;obj)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Tarchive , class TElem &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="namespaceelm.html#ac20352760a019c40a2b3559fed186341">elm::Save</a> </td>
          <td>(</td>
          <td class="paramtype">Tarchive &amp;&#160;</td>
          <td class="paramname"><em>ar</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const cv::Mat_&lt; TElem &gt; &amp;&#160;</td>
          <td class="paramname"><em>obj</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="ser__mat__utils_8h_source.html#l00016">16</a> of file <a class="el" href="ser__mat__utils_8h_source.html">ser_mat_utils.h</a>.</p>

</div>
</div>
<a class="anchor" id="a717ced0dc6520c7f3b01fdef963cdfdd"></a><!-- doxytag: member="elm::Save" ref="a717ced0dc6520c7f3b01fdef963cdfdd" args="(const boost::filesystem::path &amp;p, const T &amp;obj)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="namespaceelm.html#ac20352760a019c40a2b3559fed186341">elm::Save</a> </td>
          <td>(</td>
          <td class="paramtype">const boost::filesystem::path &amp;&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>obj</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="file__serialization_8h_source.html#l00041">41</a> of file <a class="el" href="file__serialization_8h_source.html">file_serialization.h</a>.</p>

</div>
</div>
<a class="anchor" id="a6b28c339e53f53455b44833735a5fc69"></a><!-- doxytag: member="elm::SwapEndian" ref="a6b28c339e53f53455b44833735a5fc69" args="(T *p)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="namespaceelm.html#a6b28c339e53f53455b44833735a5fc69">elm::SwapEndian</a> </td>
          <td>(</td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>p</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Perform Endian Swap Useful when integers in binary files are stored in the MSB first (high endian) format used by most non-Intel processors, but read on a platform with an Intel processor and other low-endian machines. </p>
<p>Those have to flip the bytes of those integers.</p>
<p>source: <a href="http://stackoverflow.com/questions/3823921/convert-big-endian-to-little-endian-when-reading-from-a-binary-file">http://stackoverflow.com/questions/3823921/convert-big-endian-to-little-endian-when-reading-from-a-binary-file</a></p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">reference</td><td>to value to flip in place </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="binary_8h_source.html#l00053">53</a> of file <a class="el" href="binary_8h_source.html">binary.h</a>.</p>

</div>
</div>
<a class="anchor" id="a8a54b057b1c7ddd03aee880f47d21254"></a><!-- doxytag: member="elm::to_string" ref="a8a54b057b1c7ddd03aee880f47d21254" args="(const std::vector&lt; T &gt; &amp;v, const std::string &amp;delim=&quot;, &quot;)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::string <a class="el" href="namespaceelm.html#a8a54b057b1c7ddd03aee880f47d21254">elm::to_string</a> </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>delim</em> = <code>&quot;,&#160;&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="modules_2elm_2core_2stl_2stl__inl_8h_source.html#l00100">100</a> of file <a class="el" href="modules_2elm_2core_2stl_2stl__inl_8h_source.html">modules/elm/core/stl/stl_inl.h</a>.</p>

</div>
</div>
<a class="anchor" id="a12bddc1fe054e0e0110d9de3e49cc77c"></a><!-- doxytag: member="elm::toPythonList" ref="a12bddc1fe054e0e0110d9de3e49cc77c" args="(std::vector&lt; T &gt; v)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">boost::python::list <a class="el" href="namespaceelm.html#a12bddc1fe054e0e0110d9de3e49cc77c">elm::toPythonList</a> </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; T &gt;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Convert an C++ STL vector to a python list credits: <a href="https://gist.github.com/octavifs/5362272">https://gist.github.com/octavifs/5362272</a>. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">v</td><td>vector </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>list </dd></dl>

<p>Definition at line <a class="el" href="bindings_2elm_2python_2stl__inl_8h_source.html#l00016">16</a> of file <a class="el" href="bindings_2elm_2python_2stl__inl_8h_source.html">bindings/elm/python/stl_inl.h</a>.</p>

</div>
</div>
<a class="anchor" id="ace0198649e59df697bc14710d785ab27"></a><!-- doxytag: member="elm::total" ref="ace0198649e59df697bc14710d785ab27" args="(const cv::SparseMat &amp;m)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t <a class="el" href="namespaceelm.html#ace0198649e59df697bc14710d785ab27">elm::total</a> </td>
          <td>(</td>
          <td class="paramtype">const cv::SparseMat &amp;&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get total number of elements that can be occupied in this sparse matrix. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">m</td><td>sparse mat </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>product of sizes </dd></dl>

</div>
</div>
<a class="anchor" id="a0985d63df87c4447864e729ad0f84519"></a><!-- doxytag: member="elm::TriangleEdges" ref="a0985d63df87c4447864e729ad0f84519" args="(const pcl::PointXYZ &amp;p0, const pcl::PointXYZ &amp;p1, const pcl::PointXYZ &amp;p2)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacecv.html#a9747ac59f97cbb93ddd719c4fb3e2d5d">cv::Mat1f</a> <a class="el" href="namespaceelm.html#a0985d63df87c4447864e729ad0f84519">elm::TriangleEdges</a> </td>
          <td>(</td>
          <td class="paramtype">const pcl::PointXYZ &amp;&#160;</td>
          <td class="paramname"><em>p0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const pcl::PointXYZ &amp;&#160;</td>
          <td class="paramname"><em>p1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const pcl::PointXYZ &amp;&#160;</td>
          <td class="paramname"><em>p2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="aed7de6a12a8fe869a26365ea3e0a2dce"></a><!-- doxytag: member="elm::TriangulatedCloudToAdjacency" ref="aed7de6a12a8fe869a26365ea3e0a2dce" args="(const CloudXYZPtr &amp;cld, const Triangles &amp;t, cv::Mat1f &amp;dst)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="namespaceelm.html#aed7de6a12a8fe869a26365ea3e0a2dce">elm::TriangulatedCloudToAdjacency</a> </td>
          <td>(</td>
          <td class="paramtype">const CloudXYZPtr &amp;&#160;</td>
          <td class="paramname"><em>cld</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Triangles &amp;&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacecv.html#a9747ac59f97cbb93ddd719c4fb3e2d5d">cv::Mat1f</a> &amp;&#160;</td>
          <td class="paramname"><em>dst</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get Adjacency matrix for triangulated point cloud. </p>
<p>A new Mat object will only be constructed if not previously alocated or allocated dimensions are not sufficient.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">cld</td><td>point cloud </td></tr>
    <tr><td class="paramname">t</td><td>vertices of point cloud triangulation </td></tr>
    <tr><td class="paramname">dst</td><td>dense adjacency matrix </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt><b>Exceptions:</b></dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classelm_1_1ExceptionBadDims.html">elm::ExceptionBadDims</a></td><td>if verticies don't add up to form triangle </td></tr>
    <tr><td class="paramname"><a class="el" href="classelm_1_1ExceptionKeyError.html">elm::ExceptionKeyError</a></td><td>if a triangle vertex is beyond cloud points </td></tr>
  </table>
  </dd>
</dl>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000006">Todo:</a></b></dt><dd>figure out speed difference between dense and sparse overload </dd></dl>

</div>
</div>
<a class="anchor" id="a69b3ed95dc7d8a85b72cdb15c5313131"></a><!-- doxytag: member="elm::TriangulatedCloudToAdjacency" ref="a69b3ed95dc7d8a85b72cdb15c5313131" args="(const CloudXYZPtr &amp;cld, const Triangles &amp;t, elm::SparseMat1f &amp;dst)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="namespaceelm.html#aed7de6a12a8fe869a26365ea3e0a2dce">elm::TriangulatedCloudToAdjacency</a> </td>
          <td>(</td>
          <td class="paramtype">const CloudXYZPtr &amp;&#160;</td>
          <td class="paramname"><em>cld</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Triangles &amp;&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceelm.html#a81bd2c792bb7bc6cbcd80d2d47978963">elm::SparseMat1f</a> &amp;&#160;</td>
          <td class="paramname"><em>dst</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get Adjacency matrix for triangulated point cloud. </p>
<p>A new SpareMat object will only be constructed if not previously alocated or allocated dimensions are not sufficient.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">cld</td><td>point cloud </td></tr>
    <tr><td class="paramname">t</td><td>vertices of point cloud triangulation </td></tr>
    <tr><td class="paramname">dst</td><td>sparse adjacency matrix </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt><b>Exceptions:</b></dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classelm_1_1ExceptionBadDims.html">elm::ExceptionBadDims</a></td><td>if verticies don't add up to form triangle </td></tr>
    <tr><td class="paramname"><a class="el" href="classelm_1_1ExceptionKeyError.html">elm::ExceptionKeyError</a></td><td>if a triangle vertex is beyond cloud points </td></tr>
  </table>
  </dd>
</dl>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000007">Todo:</a></b></dt><dd>figure out speed difference between dense and sparse overload </dd></dl>

</div>
</div>
<a class="anchor" id="a9c7f94adefe67d3d18a48fff2bd7f1a4"></a><!-- doxytag: member="elm::tril" ref="a9c7f94adefe67d3d18a48fff2bd7f1a4" args="(const cv::Mat1f &amp;src, std::vector&lt; cv::Mat1f &gt; &amp;dst)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="namespaceelm.html#a9c7f94adefe67d3d18a48fff2bd7f1a4">elm::tril</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacecv.html#a9747ac59f97cbb93ddd719c4fb3e2d5d">cv::Mat1f</a> &amp;&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="namespacecv.html#a9747ac59f97cbb93ddd719c4fb3e2d5d">cv::Mat1f</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>dst</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>lower triangular part of matrix </p>
<p>Diagonal excluded.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">src</td><td></td></tr>
    <tr><td class="paramname">dst</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>total no. of elements extracted </dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="namespaceelm.html#ac7d91c0a0b9de95930ed7bba11b8e026" title="lower triangular part of matrix flattened">tril_flat()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ac7d91c0a0b9de95930ed7bba11b8e026"></a><!-- doxytag: member="elm::tril_flat" ref="ac7d91c0a0b9de95930ed7bba11b8e026" args="(const cv::Mat1f &amp;src, cv::Mat1f &amp;dst)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="namespaceelm.html#ac7d91c0a0b9de95930ed7bba11b8e026">elm::tril_flat</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacecv.html#a9747ac59f97cbb93ddd719c4fb3e2d5d">cv::Mat1f</a> &amp;&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacecv.html#a9747ac59f97cbb93ddd719c4fb3e2d5d">cv::Mat1f</a> &amp;&#160;</td>
          <td class="paramname"><em>dst</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>lower triangular part of matrix flattened </p>
<p>Diagonal included.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">src</td><td></td></tr>
    <tr><td class="paramname">dst</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>total no. of elments extracted </dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="namespaceelm.html#a9c7f94adefe67d3d18a48fff2bd7f1a4" title="lower triangular part of matrix">tril()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a2759bdbeb316e08156832cd75d0dbd4c"></a><!-- doxytag: member="elm::TYPED_TEST_CASE_P" ref="a2759bdbeb316e08156832cd75d0dbd4c" args="(LearningLayer_TP_)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceelm.html#a015533ce3549f34ea2026d72abb9602f">elm::TYPED_TEST_CASE_P</a> </td>
          <td>(</td>
          <td class="paramtype">LearningLayer_TP_&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a015533ce3549f34ea2026d72abb9602f"></a><!-- doxytag: member="elm::TYPED_TEST_CASE_P" ref="a015533ce3549f34ea2026d72abb9602f" args="(Layer_TP_)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceelm.html#a015533ce3549f34ea2026d72abb9602f">elm::TYPED_TEST_CASE_P</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classelm_1_1Layer__TP__.html">Layer_TP_</a>&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a90670dbb4ab62053e01380f9dfbfb74e"></a><!-- doxytag: member="elm::TYPED_TEST_CASE_P" ref="a90670dbb4ab62053e01380f9dfbfb74e" args="(LayerFeatTransf_TP_)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceelm.html#a015533ce3549f34ea2026d72abb9602f">elm::TYPED_TEST_CASE_P</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classelm_1_1LayerFeatTransf__TP__.html">LayerFeatTransf_TP_</a>&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a9927386e25635c2fa52b52fa26cfdb37"></a><!-- doxytag: member="elm::TYPED_TEST_CASE_P" ref="a9927386e25635c2fa52b52fa26cfdb37" args="(Signal_TP_)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceelm.html#a015533ce3549f34ea2026d72abb9602f">elm::TYPED_TEST_CASE_P</a> </td>
          <td>(</td>
          <td class="paramtype">Signal_TP_&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a29068155c7097bf9813d4741f90886a0"></a><!-- doxytag: member="elm::TYPED_TEST_CASE_P" ref="a29068155c7097bf9813d4741f90886a0" args="(LayerInst_TP_)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceelm.html#a015533ce3549f34ea2026d72abb9602f">elm::TYPED_TEST_CASE_P</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classelm_1_1LayerInst__TP__.html">LayerInst_TP_</a>&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a7e5152d8dd0e56997f05071b15c27e50"></a><!-- doxytag: member="elm::TYPED_TEST_P" ref="a7e5152d8dd0e56997f05071b15c27e50" args="(LearningLayer_TP_, Clear)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceelm.html#a8fc46887c8ceea0bd74418f1e8e4f91e">elm::TYPED_TEST_P</a> </td>
          <td>(</td>
          <td class="paramtype">LearningLayer_TP_&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Clear&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="learninglayer__assertions_8h_source.html#l00044">44</a> of file <a class="el" href="learninglayer__assertions_8h_source.html">learninglayer_assertions.h</a>.</p>

</div>
</div>
<a class="anchor" id="aa45bd11895cf9bf124dfc0f56fe46e20"></a><!-- doxytag: member="elm::TYPED_TEST_P" ref="aa45bd11895cf9bf124dfc0f56fe46e20" args="(LearningLayer_TP_, Constructor)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceelm.html#a8fc46887c8ceea0bd74418f1e8e4f91e">elm::TYPED_TEST_P</a> </td>
          <td>(</td>
          <td class="paramtype">LearningLayer_TP_&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Constructor&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="learninglayer__assertions_8h_source.html#l00049">49</a> of file <a class="el" href="learninglayer__assertions_8h_source.html">learninglayer_assertions.h</a>.</p>

</div>
</div>
<a class="anchor" id="a8fc46887c8ceea0bd74418f1e8e4f91e"></a><!-- doxytag: member="elm::TYPED_TEST_P" ref="a8fc46887c8ceea0bd74418f1e8e4f91e" args="(Layer_TP_, Clear)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceelm.html#a8fc46887c8ceea0bd74418f1e8e4f91e">elm::TYPED_TEST_P</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classelm_1_1Layer__TP__.html">Layer_TP_</a>&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Clear&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="layer__assertions_8h_source.html#l00054">54</a> of file <a class="el" href="layer__assertions_8h_source.html">layer_assertions.h</a>.</p>

</div>
</div>
<a class="anchor" id="ab574c73fc410b80fba460fa9a0ab212d"></a><!-- doxytag: member="elm::TYPED_TEST_P" ref="ab574c73fc410b80fba460fa9a0ab212d" args="(LearningLayer_TP_, Destructor)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceelm.html#a8fc46887c8ceea0bd74418f1e8e4f91e">elm::TYPED_TEST_P</a> </td>
          <td>(</td>
          <td class="paramtype">LearningLayer_TP_&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Destructor&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="learninglayer__assertions_8h_source.html#l00054">54</a> of file <a class="el" href="learninglayer__assertions_8h_source.html">learninglayer_assertions.h</a>.</p>

</div>
</div>
<a class="anchor" id="a3eccaf7c9e3d0c8739eea9d8baab6c6a"></a><!-- doxytag: member="elm::TYPED_TEST_P" ref="a3eccaf7c9e3d0c8739eea9d8baab6c6a" args="(Layer_TP_, Constructor)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceelm.html#a8fc46887c8ceea0bd74418f1e8e4f91e">elm::TYPED_TEST_P</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classelm_1_1Layer__TP__.html">Layer_TP_</a>&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Constructor&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="layer__assertions_8h_source.html#l00059">59</a> of file <a class="el" href="layer__assertions_8h_source.html">layer_assertions.h</a>.</p>

</div>
</div>
<a class="anchor" id="ad286e64ff4863a7b12e668c34f119ae1"></a><!-- doxytag: member="elm::TYPED_TEST_P" ref="ad286e64ff4863a7b12e668c34f119ae1" args="(Layer_TP_, Destructor)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceelm.html#a8fc46887c8ceea0bd74418f1e8e4f91e">elm::TYPED_TEST_P</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classelm_1_1Layer__TP__.html">Layer_TP_</a>&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Destructor&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="layer__assertions_8h_source.html#l00064">64</a> of file <a class="el" href="layer__assertions_8h_source.html">layer_assertions.h</a>.</p>

</div>
</div>
<a class="anchor" id="ac47226acf23833bc7b73435787a3d2f9"></a><!-- doxytag: member="elm::TYPED_TEST_P" ref="ac47226acf23833bc7b73435787a3d2f9" args="(LayerFeatTransf_TP_, Response_exists)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceelm.html#a8fc46887c8ceea0bd74418f1e8e4f91e">elm::TYPED_TEST_P</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classelm_1_1LayerFeatTransf__TP__.html">LayerFeatTransf_TP_</a>&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Response_exists&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="layer__feat__transf__assertions_8h_source.html#l00070">70</a> of file <a class="el" href="layer__feat__transf__assertions_8h_source.html">layer_feat_transf_assertions.h</a>.</p>

</div>
</div>
<a class="anchor" id="a1dfd708f0bccb272e62cdca11c36e27c"></a><!-- doxytag: member="elm::TYPED_TEST_P" ref="a1dfd708f0bccb272e62cdca11c36e27c" args="(Layer_TP_, RequiredIONamesValidation)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceelm.html#a8fc46887c8ceea0bd74418f1e8e4f91e">elm::TYPED_TEST_P</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classelm_1_1Layer__TP__.html">Layer_TP_</a>&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">RequiredIONamesValidation&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>test around a layer's ability to validate its required io names Basically tests that <a class="el" href="classelm_1_1ExceptionKeyError.html">elm::ExceptionKeyError</a> is thrown whenever a required I/O name is not provided. </p>
<p>Generates various combinations of present and missing IO names</p>
<p>uses:</p>
<ul>
<li><a class="el" href="structelm_1_1LayerAttr__.html#ac886967b0d4e6e5d937a4f1226a08b0c" title="needs to be initialized in layer&#39;s implementation file.">LayerAttr_&lt;TypeParam &gt;::io_pairs</a> map of io name pairs</li>
<li>pointer to layer under test </li>
</ul>

<p>Definition at line <a class="el" href="layer__assertions_8h_source.html#l00080">80</a> of file <a class="el" href="layer__assertions_8h_source.html">layer_assertions.h</a>.</p>

</div>
</div>
<a class="anchor" id="a77b6e5d6e1ae2c4907ae675abb8313bc"></a><!-- doxytag: member="elm::TYPED_TEST_P" ref="a77b6e5d6e1ae2c4907ae675abb8313bc" args="(Signal_TP_, Constructor)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceelm.html#a8fc46887c8ceea0bd74418f1e8e4f91e">elm::TYPED_TEST_P</a> </td>
          <td>(</td>
          <td class="paramtype">Signal_TP_&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Constructor&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>test utility function for populating a vector with uniformly random values </p>

<p>Definition at line <a class="el" href="signal__tp___8h_source.html#l00087">87</a> of file <a class="el" href="signal__tp___8h_source.html">signal_tp_.h</a>.</p>

</div>
</div>
<a class="anchor" id="a2f3a3b9c116e9fbe6dfd1ce5aec5ea33"></a><!-- doxytag: member="elm::TYPED_TEST_P" ref="a2f3a3b9c116e9fbe6dfd1ce5aec5ea33" args="(Signal_TP_, Clear)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceelm.html#a8fc46887c8ceea0bd74418f1e8e4f91e">elm::TYPED_TEST_P</a> </td>
          <td>(</td>
          <td class="paramtype">Signal_TP_&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Clear&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="signal__tp___8h_source.html#l00092">92</a> of file <a class="el" href="signal__tp___8h_source.html">signal_tp_.h</a>.</p>

</div>
</div>
<a class="anchor" id="a071ae502cb284731ccacf397cf3c341a"></a><!-- doxytag: member="elm::TYPED_TEST_P" ref="a071ae502cb284731ccacf397cf3c341a" args="(Signal_TP_, FeatureNames)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceelm.html#a8fc46887c8ceea0bd74418f1e8e4f91e">elm::TYPED_TEST_P</a> </td>
          <td>(</td>
          <td class="paramtype">Signal_TP_&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FeatureNames&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="signal__tp___8h_source.html#l00104">104</a> of file <a class="el" href="signal__tp___8h_source.html">signal_tp_.h</a>.</p>

</div>
</div>
<a class="anchor" id="a9c0e97a9c65088b9a52483302c5691e6"></a><!-- doxytag: member="elm::TYPED_TEST_P" ref="a9c0e97a9c65088b9a52483302c5691e6" args="(Signal_TP_, GetFeatures)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceelm.html#a8fc46887c8ceea0bd74418f1e8e4f91e">elm::TYPED_TEST_P</a> </td>
          <td>(</td>
          <td class="paramtype">Signal_TP_&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">GetFeatures&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="signal__tp___8h_source.html#l00123">123</a> of file <a class="el" href="signal__tp___8h_source.html">signal_tp_.h</a>.</p>

</div>
</div>
<a class="anchor" id="a0fa6c211bdd07b39e09a6465794017d3"></a><!-- doxytag: member="elm::TYPED_TEST_P" ref="a0fa6c211bdd07b39e09a6465794017d3" args="(Signal_TP_, MostRecent_Invalid)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceelm.html#a8fc46887c8ceea0bd74418f1e8e4f91e">elm::TYPED_TEST_P</a> </td>
          <td>(</td>
          <td class="paramtype">Signal_TP_&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MostRecent_Invalid&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="signal__tp___8h_source.html#l00135">135</a> of file <a class="el" href="signal__tp___8h_source.html">signal_tp_.h</a>.</p>

</div>
</div>
<a class="anchor" id="a4e2bbacb78892b72392100b3ddf1303b"></a><!-- doxytag: member="elm::TYPED_TEST_P" ref="a4e2bbacb78892b72392100b3ddf1303b" args="(LayerInst_TP_, Clear)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceelm.html#a8fc46887c8ceea0bd74418f1e8e4f91e">elm::TYPED_TEST_P</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classelm_1_1LayerInst__TP__.html">LayerInst_TP_</a>&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Clear&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="layer__assertions_8h_source.html#l00138">138</a> of file <a class="el" href="layer__assertions_8h_source.html">layer_assertions.h</a>.</p>

</div>
</div>
<a class="anchor" id="af631c11309d8ad43f0447acd9107c6f2"></a><!-- doxytag: member="elm::TYPED_TEST_P" ref="af631c11309d8ad43f0447acd9107c6f2" args="(Signal_TP_, Append)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceelm.html#a8fc46887c8ceea0bd74418f1e8e4f91e">elm::TYPED_TEST_P</a> </td>
          <td>(</td>
          <td class="paramtype">Signal_TP_&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Append&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="signal__tp___8h_source.html#l00142">142</a> of file <a class="el" href="signal__tp___8h_source.html">signal_tp_.h</a>.</p>

</div>
</div>
<a class="anchor" id="ab9a73cb21deafd7ea31f9dd508d32328"></a><!-- doxytag: member="elm::TYPED_TEST_P" ref="ab9a73cb21deafd7ea31f9dd508d32328" args="(LayerInst_TP_, Constructor)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceelm.html#a8fc46887c8ceea0bd74418f1e8e4f91e">elm::TYPED_TEST_P</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classelm_1_1LayerInst__TP__.html">LayerInst_TP_</a>&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Constructor&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="layer__assertions_8h_source.html#l00143">143</a> of file <a class="el" href="layer__assertions_8h_source.html">layer_assertions.h</a>.</p>

</div>
</div>
<a class="anchor" id="a4c45786c87f54db7abf377c2f57c9335"></a><!-- doxytag: member="elm::TYPED_TEST_P" ref="a4c45786c87f54db7abf377c2f57c9335" args="(LayerInst_TP_, Destructor)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceelm.html#a8fc46887c8ceea0bd74418f1e8e4f91e">elm::TYPED_TEST_P</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classelm_1_1LayerInst__TP__.html">LayerInst_TP_</a>&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Destructor&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="layer__assertions_8h_source.html#l00148">148</a> of file <a class="el" href="layer__assertions_8h_source.html">layer_assertions.h</a>.</p>

</div>
</div>
<a class="anchor" id="a6604dc775bb2f33aba89680ef1056795"></a><!-- doxytag: member="elm::TYPED_TEST_P" ref="a6604dc775bb2f33aba89680ef1056795" args="(Signal_TP_, MostRecent_after_Append)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceelm.html#a8fc46887c8ceea0bd74418f1e8e4f91e">elm::TYPED_TEST_P</a> </td>
          <td>(</td>
          <td class="paramtype">Signal_TP_&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MostRecent_after_Append&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>This test looks at the most recently added feature. </p>
<p>This involves checking for equality GTEST's EXPECT_EQ macro only works if the == operator is defined for the type being passed. This is not the case for OpenCV Mat, which we make heavy use of However, the &lt;&lt; operator is defined for Mat as well as other types likely to be used. So we'll try to cirvumvent this limitation by comparing the objects in the form of string comparisons</p>
<p>We'll have to revisit this, when that assumption fails. </p>

<p>Definition at line <a class="el" href="signal__tp___8h_source.html#l00170">170</a> of file <a class="el" href="signal__tp___8h_source.html">signal_tp_.h</a>.</p>

</div>
</div>
<a class="anchor" id="a9a21421295a964aca2593ad85b2798ac"></a><!-- doxytag: member="elm::UnusedNodes" ref="a9a21421295a964aca2593ad85b2798ac" args="(const PTree &amp;p, const VecS &amp;keys_used, VecS &amp;keys_unused)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="namespaceelm.html#a9a21421295a964aca2593ad85b2798ac">elm::UnusedNodes</a> </td>
          <td>(</td>
          <td class="paramtype">const PTree &amp;&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const VecS &amp;&#160;</td>
          <td class="paramname"><em>keys_used</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VecS &amp;&#160;</td>
          <td class="paramname"><em>keys_unused</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Check PTree for unsued nodes Suitable for checking a layer is not getting extra paramters. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">PTree</td><td>to check for unused nodes </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">keys</td><td>expected to be found </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">unused</td><td>keys, keys found in addition to expected set of keys </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>true if unusued keys found </dd></dl>

</div>
</div>
<a class="anchor" id="add56d0ab3d62df55c40e0d6dc94eb0c2"></a><!-- doxytag: member="elm::Values" ref="add56d0ab3d62df55c40e0d6dc94eb0c2" args="(const std::map&lt; TKey, TVal &gt; &amp;m)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TKey , class TVal &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;TVal &gt; <a class="el" href="namespaceelm.html#add56d0ab3d62df55c40e0d6dc94eb0c2">elm::Values</a> </td>
          <td>(</td>
          <td class="paramtype">const std::map&lt; TKey, TVal &gt; &amp;&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>List all values in a map. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">map</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>vector of all map values </dd></dl>

<p>Definition at line <a class="el" href="modules_2elm_2core_2stl_2stl__inl_8h_source.html#l00072">72</a> of file <a class="el" href="modules_2elm_2core_2stl_2stl__inl_8h_source.html">modules/elm/core/stl/stl_inl.h</a>.</p>

</div>
</div>
<a class="anchor" id="adc7b5c3a1b48d23c88e688db04d452ea"></a><!-- doxytag: member="elm::Vec_ToRowMat_" ref="adc7b5c3a1b48d23c88e688db04d452ea" args="(std::vector&lt; T &gt; &amp;v)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">cv::Mat_&lt;T&gt; <a class="el" href="namespaceelm.html#adc7b5c3a1b48d23c88e688db04d452ea">elm::Vec_ToRowMat_</a> </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Function for converting STL vector of POD type into an OpenCV Mat. </p>
<p>No deep copy. The data is not copied to the matrix. The data remains owned by the vector The resulting mat object should not be referenced if the source vector goes out of scope</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">source</td><td>vector of POD type </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>resulting row matrix, matrix with single row pointing to the vector's underlying data </dd></dl>

<p>Definition at line <a class="el" href="mat__vector__utils__inl_8h_source.html#l00061">61</a> of file <a class="el" href="mat__vector__utils__inl_8h_source.html">mat_vector_utils_inl.h</a>.</p>

</div>
</div>
<a class="anchor" id="abf4cc23596a9d94b46c1c482507777f8"></a><!-- doxytag: member="elm::VecVertices2Mat" ref="abf4cc23596a9d94b46c1c482507777f8" args="(const VecVertices &amp;vv, bool do_row_mat=true)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacecv.html#a9747ac59f97cbb93ddd719c4fb3e2d5d">cv::Mat1f</a> <a class="el" href="namespaceelm.html#abf4cc23596a9d94b46c1c482507777f8">elm::VecVertices2Mat</a> </td>
          <td>(</td>
          <td class="paramtype">const VecVertices &amp;&#160;</td>
          <td class="paramname"><em>vv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>do_row_mat</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Convert vector of Vertices to a Mat of floats. </p>
<p>Unfortunately, a shallow copy did not work, this will be a deep copy</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">vector</td><td>of vertices </td></tr>
    <tr><td class="paramname">whether</td><td>to format the resulting Mat as a row matrix or not </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Mat of floats with vertex data </dd></dl>

</div>
</div>
<hr/><h2>Variable Documentation</h2>
<a class="anchor" id="a7713a3d419c89693eab7bf0f82f4540e"></a><!-- doxytag: member="elm::NA_IDX" ref="a7713a3d419c89693eab7bf0f82f4540e" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="namespaceelm.html#a7713a3d419c89693eab7bf0f82f4540e">elm::NA_IDX</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>= -1; non-applicable index </p>

</div>
</div>
</div><!-- contents -->
</div>
  <div id="nav-path" class="navpath">
    <ul>
      <li class="navelem"><a class="el" href="namespaceelm.html">elm</a>      </li>

    <li class="footer">Generated on Mon Jun 22 2015 15:33:26 for ELM Library by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.6.1 </li>
   </ul>
 </div>


</body>
</html>
